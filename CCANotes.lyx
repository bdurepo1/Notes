#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin "C:/Users/DurepoBrandonA/OneDrive - Georgia Institute of Technology/CCA/Notes/"
\textclass article
\use_default_options true
\begin_modules
theorems-ams
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format pdf2
\output_sync 1
\output_sync_macro "\synctex=1"
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Computability, Complexity, and Algorithms Course Notes"
\pdf_author "Brandon A. Durepo"
\pdf_keywords "Algorithms, Automata, Computabilty, Complexity, Analysis"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Notes on Computability, Complexity, and Algorithms – An Ode to the Unprepared
 Student
\end_layout

\begin_layout Author
Brandon A.
 Durepo, 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

bdurepo@gatech.edu
\end_layout

\end_inset


\end_layout

\begin_layout Quote
\noindent
\align right
\begin_inset Quotes eld
\end_inset

Sapere aude.
\begin_inset Quotes erd
\end_inset

 – Horace
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section*
Preface
\end_layout

\begin_layout Standard
The purpose of this document is to help students of all stripes succeed
 in Georgia Tech's course on Computability, Complexity and Algorithms more
 formally known as CS6505.
 Many students find this course to be challenging and the topics can be
 opaque at times to the newcomer.
 However with grit, determination, and luck you, the reader, can reap the
 many benefits that this course offers.
 In proceeding sections I outline some of the key concepts you will need
 to be successful in the course.
 I make no assumptions about prerequisite knowledge and attempt to provide
 you the green field perspective on the subject matter.
 In many cases, if you have already seen the information it is safe to skip
 forward and not concern yourself what may be obvious to you, but I encourage
 you to read all the sections because additional clarity may be gained with
 another pass through.
\end_layout

\begin_layout Part
Mathematics and Logic
\end_layout

\begin_layout Section
Discrete Mathmatics
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Equivalence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\land T\equiv p$
\end_inset

, 
\begin_inset Formula $p\lor F\equiv F$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identity Laws
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\lor T\equiv T$
\end_inset

, 
\begin_inset Formula $p\land F\equiv F$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Domination Laws
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\lor p\equiv p$
\end_inset

, 
\begin_inset Formula $p\land p\equiv p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Idempotent Laws
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot(\lnot p)\equiv p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Double Negation Laws
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\lor q\equiv q\lor p$
\end_inset

, 
\begin_inset Formula $p\land q\equiv q\land p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Communatative Laws
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(p\lor q)\lor r\equiv p\lor(q\lor r)$
\end_inset

, 
\begin_inset Formula $(p\land q)\land r\equiv p\land(q\land r)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Associative Laws
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\lor(q\land r)\equiv(p\lor q)\land(p\lor r)$
\end_inset

, 
\begin_inset Formula $p\land(q\lor r)\equiv(p\land q)\lor(p\land r)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Distributive Laws
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot(p\land q)\equiv\lnot p\lor\lnot q$
\end_inset

, 
\begin_inset Formula $\lnot(p\lor q)\equiv\lnot p\land\lnot q$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
De Morgan's Law
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\lor(p\land q)\equiv p$
\end_inset

, 
\begin_inset Formula $p\land(p\lor q)\equiv p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Absoption Law
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\lor\lnot p\equiv T$
\end_inset

, 
\begin_inset Formula $p\land\lnot p\equiv F$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Negation Laws
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logical Equivalences Involving Conditional Statements
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\rightarrow q\equiv\lnot p\lor q\equiv\lnot q\rightarrow\lnot p$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\lor q\equiv\lnot p\rightarrow q$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\land q\equiv\lnot(p\rightarrow\lnot q)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot(p\rightarrow q)\equiv p\land\lnot q$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(p\rightarrow q)\land(p\rightarrow r)\equiv p\rightarrow(q\land r)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(p\rightarrow r)\land(q\rightarrow r)\equiv(p\lor q)\rightarrow r$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(p\rightarrow q)\lor(p\rightarrow r)\equiv p\rightarrow(q\lor r)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(p\rightarrow r)\lor(q\rightarrow r)\equiv(p\land q)\rightarrow r$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Logical Equivalences Involving Biconditional Statements
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\leftrightarrow q\equiv(p\rightarrow q)\land(q\rightarrow p)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\leftrightarrow q\equiv\lnot p\leftrightarrow\lnot q$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\leftrightarrow q\equiv(p\land q)\lor(\lnot p\land\lnot q)\lor(\lnot p\land\lnot q)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot(p\leftrightarrow q)\equiv p\leftrightarrow\lnot q$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:lawsOfLogic"

\end_inset

 Logical equivalences.
 Idemepotent denotes an element of a set that is unchanged in value when
 multiplied or otherwise operated on by itself.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Propositional and Sentential Logic
\begin_inset CommandInset label
LatexCommand label
name "sec:propositionalSententialLogic"

\end_inset


\end_layout

\begin_layout Standard
All logical expressions can be described in some combination of 
\emph on
logical operators
\emph default
 and 
\emph on
implications
\emph default
.
 The logical operators consist of the following: the logical conjunction
 
\begin_inset Formula $\land$
\end_inset

, the logical disjunction 
\begin_inset Formula $\lor$
\end_inset

, and the negation 
\begin_inset Formula $\lnot$
\end_inset

.
 The implication is made up of two propositional variables 
\begin_inset Formula $p$
\end_inset

and 
\begin_inset Formula $q.$
\end_inset

 
\begin_inset Formula $p$
\end_inset

is often called the 
\emph on
premise
\emph default
 or 
\emph on
hypothesis
\emph default
 or 
\emph on
antecedent
\emph default
, while 
\begin_inset Formula $q$
\end_inset

may be referred to as the 
\emph on
conclusion
\emph default
, or 
\emph on
consequence
\emph default
.
 Truth tables are a way of tabulating the values of arbitrary logical expression
s by enumerating all possible truth values for the componenet of the expressions.
 The usefulness of this technique quickly dimminishes as the number of propositi
on variables goes beyond 4.
 In this case the number of rows in the truth table is 
\begin_inset Formula $2^{4}=16$
\end_inset

.
 The precedence of logical operators is negation, conjunction, disjunction.
\end_layout

\begin_layout Standard
The implication is given by the symbol 
\begin_inset Formula $\rightarrow$
\end_inset

.
 Variations on the traditional implication of 
\begin_inset Formula $p\rightarrow q$
\end_inset

 include its 
\emph on
converse
\emph default
 
\begin_inset Formula $q\rightarrow p$
\end_inset

, the 
\emph on
contraposative
\emph default
 
\begin_inset Formula $\lnot q\rightarrow\lnot p$
\end_inset

, and the 
\emph on
inverse
\emph default
 
\begin_inset Formula $\lnot p\rightarrow\lnot q$
\end_inset

.
 A biconditional or bimplicational statement is a slightly more creative
 way to use the implication.
 A table of logical equivalances is provided in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:lawsOfLogic"

\end_inset

.
\end_layout

\begin_layout Standard
Use of these laws can allow you to estabish an equivalance of complex propositio
nal statements with a more distilled simplified version.
 Propositional statements are said to be 
\emph on
satisfiable
\emph default
 if some combination of truth assignments to the propostional variables
 makes the statement true.
\end_layout

\begin_layout Subsection
Predicate Calculus and Quantification Logic
\end_layout

\begin_layout Standard
Predicate logic is a generalization of propositional logic onto arbitrary
 statements.
 
\emph on
Propositonal functions
\emph default
 given by a capital letter and a number of parameters are used to define
 propositional statements.
 An example, 
\begin_inset Quotes eld
\end_inset

Computer 
\begin_inset Formula $x$
\end_inset

, is functioning properly
\begin_inset Quotes erd
\end_inset

 would be written as 
\begin_inset Formula $P(x).$
\end_inset

 
\end_layout

\begin_layout Standard
Quantification expresses the extent to which a predicate is true over a
 range of elements.
 In English, the words all, some, many, none, and few are used in quantification
s.
 The 
\emph on
univeral quantification
\emph default
 symbol for all is given by 
\begin_inset Formula $\forall$
\end_inset

.
 The 
\emph on
existential quantifiaction
\emph default
 symbol for exists is 
\begin_inset Formula $\exists$
\end_inset

.
 The statement 
\begin_inset Formula $\forall xP(x)$
\end_inset

 reads 
\begin_inset Quotes eld
\end_inset

For all computers given by 
\begin_inset Formula $x$
\end_inset

, computer 
\begin_inset Formula $x$
\end_inset

is functioning properly.
\begin_inset Quotes erd
\end_inset

 If there is a single instance of a universal varaible which is false then
 the predicate becomes false.
 If for all instances of an existential varaibles the value is false then
 the statement is false.
 Quantification operators have higher precedence than logical operators.
 Predicates used with quantifiers are said to be 
\emph on
bound variables
\emph default
 while those without are said to be 
\emph on
free variables
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot\forall xP(x)\equiv\exists x\lnot P(x).$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\lnot\exists xP(x)\equiv\forall\lnot P($
\end_inset

x).
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:quantificationNegation"

\end_inset

 This table shows the equivalance relations on predicates with quantification
 symbols.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Rules of Inference
\end_layout

\begin_layout Standard
The 
\emph on
validity
\emph default
 of a proofs arguments are derived from the truth of the premises it offers.
 An argument in propositional logic is a sequence of propositions.
 All but the final proposition in the argument are called premises and the
 final proposition is called the conclusion.An argument is valid if the truth
 of all its premises implies that the conclusion is true.
 An argument form in propositional logic is a sequence of compound propositions
 involving propositional variables.
 An argument form is valid no matter which particular propositions are substitut
ed for the propositional variables in its premises, the conclusion is true
 if the premises are all true.
 The rules of inference provide the templates of logical propostions which
 when given in a valid combitation yield valid arguments.
 The rules are given in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:inferenceRules"

\end_inset

.
 Additonally the Rules of Inference applies to quantification logic as well
 as shown in the table.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tautology
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(p\land(p\rightarrow q))\rightarrow q$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modus ponens
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(\neg q\land(p\rightarrow q))\rightarrow q$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modus tollens
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $((p\rightarrow q)\land(q\rightarrow r))\rightarrow(p\rightarrow r)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hypothetical syllogism
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $((p\lor q)\land\neg p)\rightarrow q$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Disjunctive syllogism
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\rightarrow(p\lor q)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Addition
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(p\land q)\rightarrow q$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Simplification
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $((p)\land(q))\rightarrow(p\land q)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Conjunction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(p\lor q)\land(\neg p\lor r)\rightarrow(q\lor r)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Resolution
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Inference Rule
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{\forall xP(x)}{\therefore P(c)}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Universal instantiation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{P(c)}{\therefore\forall xP(x)}$
\end_inset

 for an arbitrary 
\begin_inset Formula $c$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Universal generalization
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{\exists xP(x)}{\therefore P(c)}$
\end_inset

 for some element 
\begin_inset Formula $c$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Existantial instantiation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{P(c)}{\therefore\exists xP(x)}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Existential generalization
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:inferenceRules"

\end_inset

This table gives the Rules of Inference.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Proofs
\end_layout

\begin_layout Standard
In order to begin to understand how to construct valid proof it is important
 to understand the terminology that is used.
 
\end_layout

\begin_layout Subsubsection
Terminology of Proofs
\end_layout

\begin_layout Itemize
a 
\emph on
theorem
\emph default
 is a statement that can be shown to be true.
\end_layout

\begin_layout Itemize
A 
\emph on
proof
\emph default
 is a valid argument that establishes the truth of a theorem.
\end_layout

\begin_layout Itemize

\emph on
axioms
\emph default
 (or 
\emph on
postulates
\emph default
) are statements we assume to be true.
\end_layout

\begin_layout Itemize
A 
\emph on
lemma
\emph default
 is a less important theorem that is helpful in the proof of other results.
\end_layout

\begin_layout Itemize
A 
\emph on
corollary
\emph default
 is a theorem that can be established directly from a theorem that has been
 proved.
\end_layout

\begin_layout Itemize

\emph on
without loss of generality
\emph default
 (WLOG) means that the author of a proof is omitting the proof of one of
 the cases in a proof by cases.
\end_layout

\begin_layout Subsubsection
Types of Proofs
\end_layout

\begin_layout Itemize

\emph on
Direct Proofs
\emph default
 is a proof that assumes the antecedent of the implication is true and seeks
 to justify and prove the conclusion of the theorem by examining the characteris
tics of the relationship of the antecedent and conclusion.
 A direct proof may use axioms, definitions, and previously proven theorems,
 together with rules of inference, to show that q must also be true.
 Here we are establishing the truth of the proof based on row 1 of the truth
 table found in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:implicationTruthTable"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $q$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\rightarrow q$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $q$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\neg q\rightarrow\neg p$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:implicationTruthTable"

\end_inset

 Truth table for the implication and its contraposition.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In juxtaposition to the direct proof we have the indirect proof techniques.
 Indirect proofs do not start with the assumption of the truth of the premise
 to derive the truth of the conclusion.
 The
\emph on
 Proof by Contraposition 
\emph default
technique takes advantage of the equivalance of the contrapostion of the
 implication to prove the conclusion.
 That is, 
\begin_inset Formula $\neg q\rightarrow\neg p\equiv p\rightarrow q$
\end_inset

 as shown in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:lawsOfLogic"

\end_inset

.
 The template for this type of proof is constructed by assuming the conclusion
 
\begin_inset Formula $q$
\end_inset

is false which implies that the premise 
\begin_inset Formula $p$
\end_inset

 is also false.
 
\end_layout

\begin_layout Itemize
The trivial and vacuous proofs strategies are the simplest strategies.
 A 
\emph on
Trivial Proof
\emph default
 is a proof that derives the truth of the conclusion based on the fact that
 the premise is false.
 This logic is based on row 3 of the implication truth table.
 A Vacuous Proof is a proof based on the fact the conclusion is true also
 show in row 3.
\end_layout

\begin_layout Itemize

\emph on
Proofs by Contradiction 
\emph default
seek to find a contradictory conclusion 
\begin_inset Formula $q=r\land\neg r$
\end_inset

, such that 
\begin_inset Formula $\neg p\rightarrow q$
\end_inset

 is true.
 We must show that 
\begin_inset Formula $p$
\end_inset

is true by showing 
\begin_inset Formula $\neg p$
\end_inset

 is false so that we can target row 4 in the implication truth table.
 
\end_layout

\begin_layout Itemize

\emph on
Proofs of Equivalance 
\emph default
To prove a theorem that is a biconditional statement, that is, a statement
 of the form 
\begin_inset Formula $p\leftrightarrow q$
\end_inset

, we show that 
\begin_inset Formula $p\rightarrow q$
\end_inset

 and 
\begin_inset Formula $q\rightarrow p$
\end_inset

.
 The validity of this approach is based on the tautology 
\begin_inset Formula $(p\leftrightarrow q)\equiv(p\rightarrow q)\land(q\rightarrow p)$
\end_inset


\end_layout

\begin_layout Itemize

\emph on
Proofs by Counterexample 
\emph default
in this type of proof we typically try to debunk the truth of a univeral
 quantifier over some predicate.
 If we find one instance is false, then we can conclude the predicate is
 false
\emph on
.
\end_layout

\begin_layout Itemize

\emph on
Proof by Cases and the Exhaustive Proof 
\emph default
sometimes using a single argument to cover the premise of a proof is not
 sufficient.
 As an alternative, we can devises cases that cover the entire domain of
 the proof and address each case in turn to prove the conclusion.
 This proof technique relies on the following tautology.
\begin_inset Formula 
\[
[(p_{1}\lor p_{2}\lor\ldots\lor p_{n})\rightarrow q]\leftrightarrow[(p_{1}\rightarrow q)\land(p_{2}\rightarrow q)\land\ldots\land(p_{n}\rightarrow q)]
\]

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Existence Proofs 
\emph default
a proof of this type is of the form 
\begin_inset Formula $\exists xP(x)$
\end_inset

.
 This type of proof can be proven by providing a 
\emph on
witness
\emph default
 
\begin_inset Formula $a,$
\end_inset

 a instance of 
\begin_inset Formula $x$
\end_inset

where 
\begin_inset Formula $P(a)$
\end_inset

 is true.
 This type of strategy is called a 
\emph on
constructive
\emph default
 proof.
 A nonconstuctive existance uses some other means to prove that 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\exists xP(x)$
\end_inset

.
 Often contradition is used.
\end_layout

\begin_layout Itemize

\emph on
Uniqueness Proofs 
\emph default
in this type of proof we show that a unique element with a particular property
 exists.
 These types of proofs are composed of two steps.
 First you must prove the existance of the element.
 Then we show that if 
\begin_inset Formula $y\neq x$
\end_inset

, then 
\begin_inset Formula $y$
\end_inset

does not have the particular property of 
\begin_inset Formula $x.$
\end_inset

 Formally, uniqueness proofs are of the form:
\begin_inset Formula 
\[
\exists x(P(x)\land\forall y(y\neq x\rightarrow\neg P(y))).
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Direct Methods
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Indirect Methods
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Direct Proof
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Proof by Contraposition
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Proof by Cases
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Proof by Contradiction
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Exhaustive Proof
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Proof by Counterexample
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Existence Proof
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Uniqueness Proof
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Classification of the proof strategies
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Strategies for Constructing Proofs
\end_layout

\begin_layout Standard
The following general approach for constructing proofs is often helpful.
\end_layout

\begin_layout Enumerate
Replace terms by their definitions.
\end_layout

\begin_layout Enumerate
Analyze the hypothesis and conclusion.
\end_layout

\begin_layout Enumerate
Attempt to construct the proof using the direct proof method, if the statement
 is a coditional statement.
\end_layout

\begin_deeper
\begin_layout Enumerate
If you fail to construct a direct proof, attempt to provide an indirect
 proof.
\end_layout

\begin_layout Enumerate
If both the direct and indirect proof methods don't work, then attempt a
 proof by contradiction.
\end_layout

\end_deeper
\begin_layout Standard

\emph on
Forward reasoning
\emph default
 as well as
\emph on
 backward reasoning
\emph default
 is necessary to construct valid proofs.
 Forward reasoning uses premises as well as previously proven theorems and
 axioms to prove the conclusion.
 In a direct proof this is the method of choice.
 Indirect proofs often will often require backward reasoning.
 In backward reasoning we attempt to find a statement 
\begin_inset Formula $p$
\end_inset

that we can prove true with 
\begin_inset Formula $p\rightarrow q.$
\end_inset


\end_layout

\begin_layout Standard

\emph on
Adapatation 
\emph default
of existing proofs is often a fruitful procedure.
 Even if the final conclusions required are not the same, it may be constructive
 to look to the previous proves for ideas which may help in your new proof.
\end_layout

\begin_layout Subsection
Sets
\begin_inset CommandInset label
LatexCommand label
name "sec:Sets"

\end_inset


\end_layout

\begin_layout Subsection
Relations
\begin_inset CommandInset label
LatexCommand label
name "sec:Relations"

\end_inset


\end_layout

\begin_layout Subsection
Functions
\begin_inset CommandInset label
LatexCommand label
name "sec:Functions"

\end_inset


\end_layout

\begin_layout Subsection
Induction
\begin_inset CommandInset label
LatexCommand label
name "sec:Induction"

\end_inset


\end_layout

\begin_layout Subsection
Modular Arithmatic
\end_layout

\begin_layout Standard
Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:moduluarArithmatic"

\end_inset

 gives an overview of basic modular arithmatic operations.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Arithmetic Property
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Equation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modulo Positive Numbers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a\%b=c$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modulo Negative Numbers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $c=a-q\cdot b$
\end_inset

, where 
\begin_inset Formula $a<0$
\end_inset

, and 
\begin_inset Formula $-1\leq q\leq\left\lfloor a/b\right\rfloor $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modular Congruence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a\%b\equiv b\%c$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modular Addition
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(a+b)\%c\equiv(a\%c+b\%c)\%c$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modular Subtraction
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(a-b)\%c\equiv(a\%c-b\%c)\%c$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modular Multiplication
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(a\cdot b)\%c\equiv(a\%c\cdot b\%c)\%c$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:moduluarArithmatic"

\end_inset

This table gives an overview of useful modular arithmatic equations
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Calculus and Real Analysis
\end_layout

\begin_layout Subsection
Sequences and Series
\end_layout

\begin_layout Subsection
Topology of Real Numbers
\end_layout

\begin_layout Subsection
Functional Limits and Continuity
\end_layout

\begin_layout Subsection
Derivatives
\end_layout

\begin_layout Subsection
Sequences and Series of Functions
\end_layout

\begin_layout Subsection
Rieman Integral
\end_layout

\begin_layout Subsection
Cantor Diagonalization
\end_layout

\begin_layout Section
Probability and Statistics
\begin_inset CommandInset label
LatexCommand label
name "sec:Probability-and-Odds"

\end_inset


\end_layout

\begin_layout Subsection
Discrete Probability Distributions
\end_layout

\begin_layout Subsection
Continuous Probability Distributions
\end_layout

\begin_layout Subsection
Combinatorics
\end_layout

\begin_layout Subsection
Condiational Probability
\end_layout

\begin_layout Subsection
Expected Value and Variance
\end_layout

\begin_layout Subsection
Sample Space and Probability
\end_layout

\begin_layout Subsection
Discrete Random Variables
\end_layout

\begin_layout Subsection
General Random Variables
\end_layout

\begin_layout Subsection
Limit Theorems
\end_layout

\begin_layout Section
Linear Algebra and Integer Linear Programming
\begin_inset CommandInset label
LatexCommand label
name "sec:Linear-Programming"

\end_inset


\end_layout

\begin_layout Subsection
Linear Equations in Linear Algebra
\end_layout

\begin_layout Subsection
Matrix Algebra
\end_layout

\begin_layout Subsection
Determinants
\end_layout

\begin_layout Subsection
Vector Spaces
\end_layout

\begin_layout Subsection
Eigenvalues and Eigenvectors
\end_layout

\begin_layout Subsection
Orthogonality and Least Squares
\end_layout

\begin_layout Subsection
Symmetric Matrices and Quadratic Forms
\end_layout

\begin_layout Subsection
Geometry of Vector Spaces
\end_layout

\begin_layout Subsection
Basic Properties of Linear Progams
\end_layout

\begin_layout Subsection
The Simplex Method
\end_layout

\begin_layout Subsection
Duality and the Complementarity
\end_layout

\begin_layout Subsection
Interior Point Methods
\end_layout

\begin_layout Part
Computability
\end_layout

\begin_layout Section
Deterministic Finite Automata
\begin_inset CommandInset label
LatexCommand label
name "sec:deterministicFiniteAutomata"

\end_inset


\end_layout

\begin_layout Standard
Finite automata are a systems of information represented by states, transitions,
 and inputs.
 Information about the computation is derived from the state in which the
 automata exists and no previous information can be remembered by the finite
 automata.
 The limits to which the finite automata can model information are expressed
 by the number of states.
\end_layout

\begin_layout Subsection
Notation of DFA's
\begin_inset CommandInset label
LatexCommand label
name "subsec:Notation-of-DFA's"

\end_inset


\end_layout

\begin_layout Standard
Traditionally finite automata
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
automata
\end_layout

\end_inset

 are expressed by a tuple of sets which express its behavior.
 The tuple, for example 
\begin_inset Formula $L=(Q,\Sigma,\delta,q_{0},F)$
\end_inset

, contains information on the states expressed by the set Q, the input alphabet
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
alphabet
\end_layout

\end_inset

 expressed by the set 
\begin_inset Formula $\Sigma$
\end_inset

, the transitions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
transitions
\end_layout

\end_inset

 expressed by the function 
\begin_inset Formula $\delta$
\end_inset

, the starting state given by 
\begin_inset Formula $q_{0}$
\end_inset

, and the set of final states given by 
\begin_inset Formula $F$
\end_inset

.
 An example of a finite automata can be seen in Figure
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:productDFA"

\end_inset

.
 Strings are typically represented by variables of lowercase letters at
 the end of the alphabet ( w, x, y, and z) whereas characters are represented
 variables of lowercase letters at the beginning of the English alphabet
 ( a, b, and c).
 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 represents the set of all strings over the alphabet 
\begin_inset Formula $\Sigma$
\end_inset

 including the empty string–the super-script star symbol is referred to
 as the Kleene star
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Kleene star
\end_layout

\end_inset

.
 The empty string is denoted by the epsilon symbol 
\begin_inset Formula $\epsilon$
\end_inset

.
 The empty string denotes a string of length 0, a string of no characters.
 Length is often expressed by vertical bars surrounding the string in question,
 such as 
\begin_inset Formula $|w|$
\end_inset

.
 A transition function 
\begin_inset Formula $\delta$
\end_inset

 takes two parameters, a state and an input symbol, and returns the next
 state to which the automaton should transition on input of the symbol (
 i.
 e 
\begin_inset Formula $\delta(q,$
\end_inset

a)).
 
\end_layout

\begin_layout Subsection
Computation of DFA's
\begin_inset CommandInset label
LatexCommand label
name "subsec:Computation-of-DFA's"

\end_inset


\end_layout

\begin_layout Standard
Given a finite automata, computation can be carried out on an input string
 by processing each character of the input one-by-one and following the
 transitions based on the input character.
 by Upon encountering the last character in the input string computation
 stops and based on whether the state is a final state (accepting state)
 or a nonaccepting state, the string is either accepted or rejected.
 Accepted strings are said to be in the language of the automaton rejected
 strings are not in the language.
 Given an automaton 
\begin_inset Formula $A$
\end_inset

 the language of 
\begin_inset Formula $A$
\end_inset

 is denoted 
\begin_inset Formula $L(A)$
\end_inset

.
 A language is a subset of 
\end_layout

\begin_layout Subsection
Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:Regular-Languages"

\end_inset


\end_layout

\begin_layout Standard
A language is a regular language
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
regular language
\end_layout

\end_inset

 if it is accepted by some 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
deterministic finite automata (DFA
\end_layout

\end_inset

deterministic finite automata (DFA).
 A caveat here is that the DFA must accept only those strings in the language
 it models and no others.
 Nonregular languages are those that cannot be modeled by a DFA.
 Examples of nonregular languages are those that require automata to count
 beyond a finite number of states.
 The classical example is the language L = {
\begin_inset Formula $0^{n}1$
\end_inset


\begin_inset Formula $^{n}$
\end_inset

 | 
\begin_inset Formula $n\geq1$
\end_inset

}.
 DFA's cannot check for the same number of symbols in a string or balanced
 parenthesis.
 This job falls to context free grammars.
\end_layout

\begin_layout Section
Nondeterministic Finite Automata
\begin_inset CommandInset label
LatexCommand label
name "sec:Nondeterministic-Finite-Automata"

\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nondeterministic finite automaton (NFA)
\end_layout

\end_inset

nondeterministic finite automaton (NFA) differs from its deterministic counterpa
rt in that it may be in many states at once.
 Transitions on an input symbol may proceed to any number states.
 This idea is demonstrated in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:nfaExample"

\end_inset

.
 NFA's are equivalent to DFA's and such anything that can be modeled with
 a NFA can be modeled with a DFA.
 Thus, the class of languages modeled by NFA's is the regular languages.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/nfaExample.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:nfaExample"

\end_inset

The NFA depicted in the diagram shows that on input symbol 
\begin_inset Formula $a$
\end_inset

the automaton transitions to the state 
\begin_inset Formula $q_{1},q_{2}$
\end_inset

 and 
\begin_inset Formula $q_{3}$
\end_inset

 at the same time.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Proof of Equivalence of NFA's and DFA's
\begin_inset CommandInset label
LatexCommand label
name "subsec:Proof-of-Equivalence"

\end_inset


\end_layout

\begin_layout Standard
The proof of equivalence between DFA's and NFA's is often called the Subset
 Construction.
 In the succeeding proof given a NFA the states 
\begin_inset Formula $Q_{N}$
\end_inset

, inputs 
\begin_inset Formula $\Sigma$
\end_inset

, transition function 
\begin_inset Formula $\delta_{N}$
\end_inset

, start state q, and final states 
\begin_inset Formula $F$
\end_inset

.
 The set of states of the constructed DFA 
\begin_inset Formula $Q_{D}$
\end_inset

 = 2
\begin_inset Formula $^{Q_{N}}$
\end_inset

, that is the power set of the set of states of the NFA.
 A power set of a set is defined as the set of all possible subsets of a
 given set.
 The inputs to the DFA will be the same as the inputs of the NFA, 
\begin_inset Formula $\Sigma$
\end_inset

.
 The start state of the DFA is the set containing the start state, 
\begin_inset Formula $q_{0}$
\end_inset

 of the NFA.
 The DFA states are named such that they enumerate the powerset's subsets
 with labels that correspond to the states of the NFA.
 The transition function for the DFA, 
\begin_inset Formula $\delta_{D}$
\end_inset

 is defined by 
\begin_inset Formula $\delta_{D}(\{q_{1,}q_{2},\ldots q_{k}\},a)$
\end_inset

 is the union over all i, for i = 1
\begin_inset Formula $\ldots k$
\end_inset

 of the NFA's transition function 
\begin_inset Formula $\delta_{N}(q_{i},a)$
\end_inset

.
 To prove equivalence of the DFA and NFA representation we must show that
 
\begin_inset Formula $\delta_{N}(q_{0},w)=\delta_{D}(\left\{ q_{0}\right\} ,w)$
\end_inset

.
 The proof is an induction on the string 
\begin_inset Formula $w$
\end_inset

.
 For the basis step we take 
\begin_inset Formula $w=\epsilon$
\end_inset

 : 
\begin_inset Formula $\delta_{N}(q_{0},\epsilon)=\delta_{D}(\left\{ q_{0}\right\} ,\epsilon)=\{q_{0}\}$
\end_inset

 .
 This is true by the basis rule for extending the delta function for NFA's
 and DFA's.
 We assume that the inductive hypothesis holds from strings shorter than
 
\begin_inset Formula $w$
\end_inset

.
 Let 
\begin_inset Formula $w=xa$
\end_inset

.
 The inductive hypothesis holds from the string 
\begin_inset Formula $x$
\end_inset

.
 Let 
\begin_inset Formula $\delta_{N}(q_{0},x)=\delta_{D}(\{q_{0}\},x)=S.$
\end_inset

 
\begin_inset Formula $S$
\end_inset

 represents a label for a set of states of the NFA.
 Let 
\begin_inset Formula $T$
\end_inset

 be the union over all states 
\begin_inset Formula $p$
\end_inset

 in 
\begin_inset Formula $S$
\end_inset

 of 
\begin_inset Formula $\delta_{N}(p,a).$
\end_inset

 Then 
\begin_inset Formula $\delta_{N}(q_{0},w)=\delta_{D}(\{q_{0}\},w)=T$
\end_inset

 by the rule for extending delta functions of NFA's and DFA's.
 Thus, DFA's and NFA's are equivalent.
\end_layout

\begin_layout Subsection
Conversion from NFA to DFA
\begin_inset CommandInset label
LatexCommand label
name "subsec:Conversion-from-NFA"

\end_inset


\end_layout

\begin_layout Standard
An example of a transition function on a chess board shown in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:chessBoard"

\end_inset

 is given by the NFA's transition table in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:convertNFA2DFA"

\end_inset

.
 An equivalent DFA transition table is given by the adjoining table in the
 diagram.
 A lazy conversion technique can be carried out to only include the state
 sets in the DFA only when necessary.
 An automaton modeling the NFA representation of the chess board is depicted
 in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:chessNFA2"

\end_inset

.
 A corresponding DFA automaton representation is depicted in Figure
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/chessBoard.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:chessBoard"

\end_inset

 A traditional chess board enumerating the black and red squares with odd
 and even numbers, respectively.
 In this board a transition onto state 
\begin_inset Formula $9$
\end_inset

 constitutes an accepting state.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NFA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4,6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,3,5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,5,7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,4,6,8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,3,7,9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,5,9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4,8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4,6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,7,9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6,8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DFA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 5\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1,3,5,7\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 5\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1,3,7,9\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1,3,5,7,9\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1,3,5,7\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1,3,5,7,9\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\begin_inset Formula $\left\{ 1,3,7,9\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 5\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\begin_inset Formula $\left\{ 1,3,5,7,9\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1,3,5,7,9\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:convertNFA2DFA"

\end_inset

 In the transition table for either the NFA or DFA.
 Odd numbered states can be viewed as the black squares of a chess board
 while even numbered states are the red squares.
 Note that the list of states in the NFA transitions expresses the fact
 that the NFA transitions to the enumerated states simultaneously, while
 the DFA bracketed states express the label of the single state to which
 the DFA transitions on the input symbol.
 In the DFA table the state set label 
\begin_inset Formula $\left\{ 2,4\right\} $
\end_inset

 is assigned the state 
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset

 on input r because it represents the union of the transitions of the states
 to which the NFA will transition to on input r from either state 2 or 4.
 This logic applies for all other states set given in the DFA table as well.
 Star symbols in either table indicate a final state.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/chessNFA2.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:chessNFA2"

\end_inset

 The chess NFA automaton.
 Transitions from odd numbers to even numbers occur on the input symbol
 
\begin_inset Formula $r$
\end_inset

.
 Transitions from even numbers to odd numbers occur on input symbol 
\begin_inset Formula $b$
\end_inset

.
 Transition labels have been ommited for the sake of clarity.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/chessDFA.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:chessDFA"

\end_inset

 The chess DFA automaton.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset Formula $\epsilon-$
\end_inset

NFA's
\begin_inset CommandInset label
LatexCommand label
name "sec:epsilonNFA's"

\end_inset


\end_layout

\begin_layout Standard
NFA's that allow for epsilon transitions are called epsilon NFA.
 Epsilon transitions allow for an automaton to transition between states
 without regard to the input string.
 Effectively, it allows for the computation to skip forward in the automaton
 without processing input.
 An example of an epsilon NFA is depicted in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:epsilonNFA"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/epsilonNFA.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:epsilonNFA"

\end_inset

 Epsilon transitions are marked with a 
\begin_inset Formula $\epsilon$
\end_inset

symbol.
 Upon transitioning to state 
\begin_inset Formula $q_{2}$
\end_inset

 the automaton spontaneously and in parallel transitions to states 
\begin_inset Formula $q_{1}$
\end_inset

, 
\begin_inset Formula $q_{3}$
\end_inset

 and 
\begin_inset Formula $q_{5}$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Closure of States
\begin_inset CommandInset label
LatexCommand label
name "subsec:Closure-of-States"

\end_inset


\end_layout

\begin_layout Standard
The closure of states is defined as the set of states reachable from state
 in question.
 The function is traditionally denoted 
\begin_inset Formula $CL(q).$
\end_inset

 The closure of state 
\begin_inset Formula $q2$
\end_inset

 in Figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:epsilonNFA"

\end_inset

 is 
\begin_inset Formula $\left\{ q2,q1,q3,q5\right\} $
\end_inset

.
\end_layout

\begin_layout Section
Regular Expressions
\begin_inset CommandInset label
LatexCommand label
name "sec:Regular-Expressions"

\end_inset


\end_layout

\begin_layout Standard
Regular expressions use three operations: union, concatenation, and Kleene
 star.
 Concatenation on languaguages 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

is denoted 
\begin_inset Formula $LM.$
\end_inset

 
\begin_inset Formula $LM$
\end_inset

 is defined as 
\begin_inset Formula $wx$
\end_inset

 where 
\begin_inset Formula $w\varepsilon L$
\end_inset

 and 
\begin_inset Formula $x\varepsilon M$
\end_inset

.
 Kleene star (
\begin_inset Formula $^{*})$
\end_inset

 is the set of strings formed by concatenating 0 or more strigns of 
\begin_inset Formula $L$
\end_inset

 in any order.
 The Kleene star of 
\begin_inset Formula $L$
\end_inset

 is then 
\begin_inset Formula $L^{*}=\left\{ \epsilon\right\} \cup L\cup LL\ldots$
\end_inset

 
\end_layout

\begin_layout Subsection
Precedence of Operators on Regular Expressions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Precedence-of-Operators"

\end_inset


\end_layout

\begin_layout Enumerate
Parenthesis
\end_layout

\begin_layout Enumerate
Kleene star
\end_layout

\begin_layout Enumerate
Concatenation
\end_layout

\begin_layout Enumerate
Union
\end_layout

\begin_layout Subsection
Algebraic Laws and Identities of Regular Expressions
\begin_inset CommandInset label
LatexCommand label
name "subsec:algebraicLawsAndIdentitesRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
Union is communative and associative.
 Concatenation is associative however is not communative.
\begin_inset Formula $\emptyset$
\end_inset

 is the identity for union.
\begin_inset Formula $\epsilon$
\end_inset

is the identity for concatenation.
 
\begin_inset Formula $\emptyset$
\end_inset

 is the annihilator for concatenation.
\end_layout

\begin_layout Section
Properties of Language Classes
\begin_inset CommandInset label
LatexCommand label
name "sec:propertiesOfLanguages"

\end_inset


\end_layout

\begin_layout Standard
A language class is a set of languages, and language classes have two important
 properties.
\end_layout

\begin_layout Itemize
Decision properties
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
decision properties
\end_layout

\end_inset

 - algorithms that when applied to a language determine whether a certain
 property holds (e.g.
 is a language empty).
\end_layout

\begin_layout Itemize
Closure properties
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
closure properties
\end_layout

\end_inset

 - describes the operations in which when applied to a language class produce
 another language in the same language class (e.g.
 union)
\end_layout

\begin_layout Subsection
Decision Properties of Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:DecisionPropertiesOfRegularLanguages"

\end_inset


\end_layout

\begin_layout Subsubsection
The Membership Test for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:membershipTestForRegularLanguages"

\end_inset

 
\end_layout

\begin_layout Standard
The classic decision property for languages is the Membership Test.
 That is, is a given string w in the language.
 The algorithm to determine this is simply to simulate the string on the
 DFA of the language.
 If the simulation of w on the DFA ends in an accepting state, then the
 string is in the language, otherwise the string has ended in a non-accepting
 state of the DFA and it is thus not in the language.
 
\end_layout

\begin_layout Subsubsection
The Emptiness Test for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:emptinessTestForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
Another example of decision properties is the Emptiness Problem.
 That is given a regular language, does it contain any strings at all? To
 determine whether the language has any strings first obtain the DFA-representat
ion of the language and then compute the reachable states from the start
 state.
 A good way of doing this is Breadth-First Search on the graph of the DFA.
 If a accepting state is reachable from the start state then we know that
 at least one string is in the language.
\end_layout

\begin_layout Subsubsection
The Equivalence Test for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:equivalenceTestForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
Another example of decision properties is testing whether two languages,
 L and M, are equivalent.
 Their DFA's are specified as follows: 
\begin_inset Formula $L=(Q,\Sigma,\delta_{L},A,F_{L})$
\end_inset

 and 
\begin_inset Formula $M=(R,\Sigma,\delta_{M},C,F_{M})$
\end_inset

 where 
\begin_inset Formula $Q=\{A,B\}$
\end_inset

, 
\begin_inset Formula $R=\left\{ C,D\right\} $
\end_inset

, and 
\begin_inset Formula $\Sigma=\{0,1\}$
\end_inset

.
 The transition function on each DFA, L and M can be seen in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:productDFA"

\end_inset

.
 To test equivalence one may form a product on the states of each DFA such
 that for each respective state in Q and R the product DFA's state set is
 
\begin_inset Formula $Q\times R$
\end_inset

 has a corresponding state.
 The start state for the product DFA would then be the pair 
\begin_inset Formula $\left[q_{0},r_{0}\right]$
\end_inset

 .
 The transition function would then be formed as follows: 
\begin_inset Formula $\delta(\left[q,r\right],1)=\left[\delta_{L}(q,1),\delta_{M}(r,1)\right]$
\end_inset

.
 The product DFA N pictured in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:productDFA"

\end_inset

 is assigned final states such that either the one of the state pair's respectiv
e DFA enters a final state, but not both.
 For example, the state B is a final state in the DFA L, and the state C
 is a final state in the DFA M.
 The state pair (B,D) is then marked final in the DFA N instead of (B,C)
 because the state D is not a final state in the DFA M.
 Similarly, the state pair (A,C) is marked a final state in the DFA N because
 C in final state the DFA M, but A is not a final state in the DFA L.
 This feature of only one state being accepting is used a differentiating
 characteristic to determine whether the languages of the DFA's L and M
 are equivalent.
 The languages L and M are equivalent if and only if the language of N is
 empty.
 This means that N models the feature that neither L accepts when M does
 not, nor does M accept when L does not.
 It is clear from the that the empty string 
\begin_inset Formula $\epsilon$
\end_inset

 is accepted by M and not by L and is so modeled by the pair (A,C) in N.
 N accepts the empty string and therefore, L and M are not equivalent languages.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/productDFA.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:productDFA"

\end_inset

The transition function formed on newly formed state set of 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Q\times R$
\end_inset

 corresponds to the transitions of L and M.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The Infiniteness Test for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:infinitenessTestRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
A final example of decision problems fro regular languages in the Infiniteness
 Problem.
 The problem asks, is the given regular language composed of an infinite
 number of strings? We can determine if a given language is infinite by
 examining the DFA-representation of the language.
 If the DFA has n states, and the given language has a string of n or more
 in length, then the language is infinite.
 Otherwise, the language must be finite.
 (If a language has a string of length n or more, then surely the DFA contains
 a cycle that yielded such a string).
 The proof of this idea follows: If there is a n-state DFA that accepts
 a string w of length n or more, then there must be a state that appears
 twice on the path traced out by the simulation of w on the DFA from the
 start state to the final state.
 This is because for all strings w of length n a DFA must traverse n+1 states.
 A diagram of the automaton demonstrating this principle can be seen in
 Figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:pumpingLemma"

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/pumpingLemma.svg
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pumpingLemma"

\end_inset

In the automaton pictured above a string w is formed by the the substrings
 x, y, and z.
 The substring x is the substring that takes us to the first cycle in the
 automaton.
 The cycle occurs at state q.
 The edge labeled y represents the edge which returns the string w to state
 q for the first time.
 Because the substring y is locked within the string w, that is its prefix
 is the substring x and its postfix is the substring z, it cannot be the
 empty string.
 However, the substrings x or z may be the empty string.
 Then 
\begin_inset Formula $xy^{i}z$
\end_inset

 for all 
\begin_inset Formula $i\geq0$
\end_inset

 is in the language, and therefore an infinite number of strings exist in
 the language.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Claim: If there is a string of length 
\begin_inset Formula $\geq n$
\end_inset

 in L, then there is a string of length 
\begin_inset Formula $\left[n,2n-1\right]$
\end_inset

 .
 
\end_layout

\begin_layout Standard
Proof: Because y is the first cycle on the path to the accepting state,
 the length 
\begin_inset Formula $|xy|\leq n$
\end_inset

, and more specifically, 
\begin_inset Formula $1\leq|y|\leq n$
\end_inset

 ( x and z may be empty strings).
 Some state along the path xy surely must repeat.
 If w is the shortest possible string of length n, then it cannot be longer
 than 2n.
 However, suppose it was.
 The string xz is another accepted string in the language.
 We know that xz = w - y, and the length of 
\begin_inset Formula $y\leq n$
\end_inset

, so the length of 
\begin_inset Formula $xz\geq n$
\end_inset

.
 Which means that 
\begin_inset Formula $|xz|\leq|w|$
\end_inset

, and yet at least n in length which is accepted, but we assumed that the
 were no strings that were shorter than w and of length at least n.
 Thus, if the string w were of length 
\begin_inset Formula $\geqq2n$
\end_inset

 , there is a shorter string of length 
\begin_inset Formula $\left[n,2n-1\right]$
\end_inset

 formed by removing the substrings represented by y which are 
\begin_inset Formula $\left[1,n\right]$
\end_inset

 .
 
\end_layout

\begin_layout Subsection
Closure Properties of Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:closurePropertiesOfRegularLanguages"

\end_inset


\end_layout

\begin_layout Subsubsection
Union for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:UnionForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are regular languages, then 
\begin_inset Formula $L\cup M$
\end_inset

 is also a regular language.
 The proof of this statement is as follows: Let the languages 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 be the languages of the regular expressions 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 respectively, then 
\begin_inset Formula $R+S$
\end_inset

 is a regular expression whose language is the 
\begin_inset Formula $L\cup M$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Intersection for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:IntersectionForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are regular languages, then 
\begin_inset Formula $L\cap M$
\end_inset

 is also a regular language.
 The proof of this statement is as follows: Let 
\begin_inset Formula $I$
\end_inset

 and 
\begin_inset Formula $J$
\end_inset

 be the DFA's for the regular languages 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, respectively.
 Form the product DFA 
\begin_inset Formula $K$
\end_inset

 of 
\begin_inset Formula $I$
\end_inset

 and 
\series bold

\begin_inset Formula $J$
\end_inset

 
\series default
and mark the final states of 
\begin_inset Formula $K$
\end_inset

 as the states in which both 
\begin_inset Formula $I$
\end_inset

 and 
\begin_inset Formula $J$
\end_inset

 are in final states.
 The DFA 
\begin_inset Formula $K$
\end_inset

 is now a regular language representing 
\begin_inset Formula $L\cap M$
\end_inset

.
 This idea is demonstrated in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:intersectionDFA"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/intersectionDFA.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:intersectionDFA"

\end_inset

The product DFA 
\begin_inset Formula $K$
\end_inset

 represents the intersection of 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 and its final state is the state pair for which a final state exists for
 both 
\begin_inset Formula $I$
\end_inset

 and 
\begin_inset Formula $J$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Difference for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:DifferenceForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are regular languages, then 
\begin_inset Formula $L-M$
\end_inset

 is also a regular language.
 
\begin_inset Formula $L-M$
\end_inset

 represents the strings that are in 
\begin_inset Formula $L$
\end_inset

 but not in 
\begin_inset Formula $M$
\end_inset

.
 The proof of this statement is as follows: Let 
\begin_inset Formula $I$
\end_inset

 and 
\begin_inset Formula $J$
\end_inset

 be the DFA's for the regular languages 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, respectively.
 Form the product DFA 
\begin_inset Formula $K$
\end_inset

 of 
\begin_inset Formula $I$
\end_inset

 and 
\series bold

\begin_inset Formula $J$
\end_inset

 
\series default
and mark the final states of 
\begin_inset Formula $K$
\end_inset

 as the states in which 
\begin_inset Formula $I$
\end_inset

 is in a final state and 
\begin_inset Formula $J$
\end_inset

 is not in a final state.
 The DFA 
\begin_inset Formula $K$
\end_inset

 now represents 
\begin_inset Formula $L-M$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Concatenation for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:ConcatenationForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are regular languages, then 
\begin_inset Formula $LM$
\end_inset

 is also a regular language.
 The proof of this statement is as follows: Let the languages 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 be the languages of the regular expressions 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 respectively, then 
\begin_inset Formula $RS$
\end_inset

 is a regular expression whose language is the 
\begin_inset Formula $LM$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Kleene Closure for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:KleeneClosureForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $R^{*}$
\end_inset

 is a regular expression whose language is 
\begin_inset Formula $L^{*}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Complement for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:ComplementForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
The complement of a language 
\begin_inset Formula $L$
\end_inset

 with respect to an alphabet 
\begin_inset Formula $\Sigma$
\end_inset

 such that 
\begin_inset Formula $\Sigma^{*}$
\end_inset

contains 
\begin_inset Formula $L$
\end_inset

 is the difference of 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 and the language 
\begin_inset Formula $L$
\end_inset

.
 Since 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 is surely a regular language, and regular languages are closed under difference
 as we have seen previously, then the complement 
\begin_inset Formula $\Sigma^{*}-L$
\end_inset

 is also regular.
\end_layout

\begin_layout Section
Conversion of Language Representations
\begin_inset CommandInset label
LatexCommand label
name "subsec:conversionOfLanguageRepresentations"

\end_inset


\end_layout

\begin_layout Standard
A cycle is formed on the way in which we can represent languages.
 There exists algorithms to convert from one representation to the next
 along the cycle depicted in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:representationCycle"

\end_inset

.
 As such, given a regular expression one may convert it to a DFA.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/representationCycle.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:representationCycle"

\end_inset

 This diagram describes the conversion cycle of representations such that
 from a regular expression it is possible to obtain a DFA.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
DFA Minimization
\begin_inset CommandInset label
LatexCommand label
name "sec:DFA-Minimization"

\end_inset


\end_layout

\begin_layout Standard
Minimizing a DFA can be carried out in a naive way by enumerating all smaller
 DFA's for any given DFA and checking for equivalence.
 However, this is terribly inefficient and a smarter algorithm can be used
 to generate a equivalent DFA much faster.
\end_layout

\begin_layout Subsection
DFA Minimization Algorithm
\begin_inset CommandInset label
LatexCommand label
name "subsec:DFA-Minimization-Algorithm"

\end_inset


\end_layout

\begin_layout Standard
The key idea here is to create a table used to find distinguishable states.
 Distinguishable state pairs are those that have one member of the pair
 in an accepting state while the other is not in an accepting state.
 The table used to distinguish these pairs is formed by the product of the
 DFA's states, 
\begin_inset Formula $Q\times Q$
\end_inset

.
 If states can be distinguished then they represent a state in minimum DFA,
 while those that are indistinguishable can be merged into a single state.
 Effectively, we are recursively finding the shortest distinguishable string
 for a DFA.
\end_layout

\begin_layout Section
The Pumping Lemma for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "sec:pumpingLemmaRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
For every regular language L, there is an integer n, which happens to be
 the number of states in the DFA of L, such that for every w in L of length
 
\begin_inset Formula $\geq n$
\end_inset

.
 We can write w = xyz such that the following properties hold:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $|xy|\leq n$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $|y|>0$
\end_inset


\end_layout

\begin_layout Enumerate
For all 
\begin_inset Formula $i\geq0$
\end_inset

, 
\begin_inset Formula $xy^{i}z$
\end_inset

 is in L.
\begin_inset CommandInset label
LatexCommand label
name "enu:PumpingLemmaProperty3"

\end_inset


\end_layout

\begin_layout Standard
The Pumping Lemma is useful in determining whether a language is regular
 or nonregular.
\end_layout

\begin_layout Subsection
Using the Pumping Lemma to Prove a Language is Nonregular
\begin_inset CommandInset label
LatexCommand label
name "subsec:usingThePumpingLemmaToProveALanguageIsNonregular"

\end_inset


\end_layout

\begin_layout Paragraph
Claim: L = {
\begin_inset Formula $0^{k}1$
\end_inset


\begin_inset Formula $^{k}$
\end_inset

 | 
\begin_inset Formula $k\geq1$
\end_inset

} is a nonregular language.
\end_layout

\begin_layout Standard
Proof: Suppose for the purposes of contradiction that L is a regular language,
 then there exists an n for which the properties of the Pumping Lemma hold
 true.Let w = 
\begin_inset Formula $0^{n}1$
\end_inset


\begin_inset Formula $^{n}$
\end_inset

.
 The string w can be written in the form w = xyx where each component x,
 y, z forms some substring of w where x and consist of 0's and 
\begin_inset Formula $y\not=\epsilon$
\end_inset

, and z is composed of 1's.
 However, for this to be a regular language all the properties of the Pumping
 Lemma must hold true.
 In particular particular property
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:PumpingLemmaProperty3"

\end_inset

.
 For 
\begin_inset Formula $i=2$
\end_inset

, 
\begin_inset Formula $w=xyyz$
\end_inset

.
 The string formed by this construction contains more 0's than 1's, violating
 the conditions on the language as specified in the set former.
 Similarly, if yz and consist of 1's and 
\begin_inset Formula $y\not=\epsilon$
\end_inset

, the string formed by this construction contains more 1's than 0's again
 violating the conditions of the language.
 Thus, the language must be nonregular because it does not meet the conditions
 of the Pumping Lemma.
 
\end_layout

\begin_layout Section
Context Free Grammars
\begin_inset CommandInset label
LatexCommand label
name "sec:contextFreeGrammars"

\end_inset


\end_layout

\begin_layout Standard
A context free grammar is a notation for describing languages.
 It is more powerful than regular expressions and finite automata, but still
 cannot define all possible languages.
 A context free grammar is composed of variables which stand for a set of
 strings.
 These variables are defined in terms of each other.
 These rules for how variables should be composed are often called productions.
 Take for example the language L = {
\begin_inset Formula $0^{n}1$
\end_inset


\begin_inset Formula $^{n}$
\end_inset

 | 
\begin_inset Formula $n\geq1$
\end_inset

}.
 This is a familar language that we saw earlier in the examples on what
 is not a regular language.
 A context free grammar (CFG) for 
\begin_inset Formula $L$
\end_inset

 can be defined as 
\begin_inset Formula $S\rightarrow01$
\end_inset

, 
\begin_inset Formula $S\rightarrow0S1$
\end_inset

.
 Here S is defined recursively such that there will always be an equal number
 of 0's and 1's.
\end_layout

\begin_layout Subsection
CFG Nomenclature
\begin_inset CommandInset label
LatexCommand label
name "subsec:CFGNomenclature"

\end_inset


\end_layout

\begin_layout Itemize
Terminals - symbols of the alphabet of the language being defined.
\end_layout

\begin_layout Itemize
Variables (Nonterminals) - A finite set of other symbols, each of which
 represents a language.
\end_layout

\begin_layout Itemize
Production (Rule) - a rule defining the relationships of terminals and nontermin
als.
 It has the form HEAD -> TAIL (BODY).
 The body is composed of terminals and nonterminals.
 Each production represents a language on its own and nontermials in the
 BODY represent languages on their own.
 Nonterminals are subsets of the parent language given by the head ( e.g.
 
\begin_inset Formula $A\rightarrow XY$
\end_inset

, where the concatenation of language 
\begin_inset Formula $X$
\end_inset

 and language
\begin_inset Formula $Y$
\end_inset

 forms the language 
\begin_inset Formula $A$
\end_inset

).
\end_layout

\begin_layout Itemize
Derivation - The process of repeatedly replacing symbols for terminals based
 on the productions of a CFG.
\end_layout

\begin_layout Itemize
Sentential form - the derived string.
\end_layout

\begin_layout Subsection
Conventional Usage of Context Free Grammars
\begin_inset CommandInset label
LatexCommand label
name "subsec:conventionalUsageOfContextFreeGrammars"

\end_inset


\end_layout

\begin_layout Standard
Captial letters at the beginning of the alphabet are typically used as variables
 (e.g A, B, C).
 Lowercase letters at the beginning of the alphabet are used as terminals
 (a, b, c).
 Capital letters at the end of the alphabet can be either terminals or variables
 (X, Y, Z).
 Lowercase letters at the end of the alphabet are strings containing terminals
 only (e.g.
 w, x, y, z).
 Greek letters are strings of terminals or variables (
\begin_inset Formula $\alpha,$
\end_inset


\begin_inset Formula $\beta,\gamma)$
\end_inset

.
 A star (*) indicates 0 or more steps are necessary to obtain a specified
 derivation.
 A variable followed by the epsilon symbol effectively causes the variable
 to disappear in the derivation process.
 A 
\begin_inset Formula $\Rightarrow_{lm}$
\end_inset

 indicates the sentenial form is as specified after one setp of the left
 most derivation.
 A 
\begin_inset Formula $\Rightarrow*_{lm}$
\end_inset

 indicates 0 or more leftmost derivations are required to obtain the specified
 sentential form.
 Corresponding symbols for the rightmost derivations exist as well.
\end_layout

\begin_layout Subsection
Context-Free Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:contextFreeLanguages"

\end_inset


\end_layout

\begin_layout Standard
A language that is defined by some CFG is called a context-free language.
 Intuitively, a context free language is a language that can count to infinite
 elements but not three.
 An example of a non-context freem language is 
\begin_inset Formula $L=\{0^{n}1^{n}2^{n}|n\geq1\}$
\end_inset

.
\end_layout

\begin_layout Subsection
Leftmost and Rightmost Derivations
\begin_inset CommandInset label
LatexCommand label
name "subsec:leftMostRightMostDerivations"

\end_inset


\end_layout

\begin_layout Standard
Leftmost derivations process a string's variables one-at-the-time from left
 to right.
 Similarly, the rightmost derivation is processed from right to left.
\end_layout

\begin_layout Subsection
Normal Forms for CFG's
\begin_inset CommandInset label
LatexCommand label
name "subsec:normalFormsForCFG"

\end_inset


\end_layout

\begin_layout Standard
Poorly designed context free grammars may have rules that are never used
 in the derivation of strings.
 This is similiar to a DFA that has unreachable states.
 CFG's may also have redundant productions that may be combined.
 
\end_layout

\begin_layout Subsubsection
Eliminating Useless Variables from CFG's
\begin_inset CommandInset label
LatexCommand label
name "subsec:eliminatingUselessVariables"

\end_inset


\end_layout

\begin_layout Standard
If a CFG's production never derives a terminal string, then it is useless.
 In order to discover useless productions and eliminate them we must have
 an inductive algorithm which determines how the derivation proceeds by
 marking the variables that do derive terminals.
 The variables not contained in the set discovered by the algorithm can
 then be eliminated.
 The algorithm follows: For the basis step find a productions that derive
 a string of terminals.
 If there is a production that derives a string of terminals and variables
 whose variables have productions that yields strings of terminals alone,
 then this production derives terminal strings.
 For example if there is a production 
\begin_inset Formula $A\rightarrow w$
\end_inset

, where 
\begin_inset Formula $w$
\end_inset

 consists only of terminals, then this qualifies as our basis.
 If we then have a prodcution 
\begin_inset Formula $A\rightarrow\alpha$
\end_inset

 who derives a string of variables and terminals than theis may qualify
 for our inductive step.
 Additionally, we may have unreachable variables in the grammar.
 Variables that are unreachable can be eliminated from the grammar by an
 induction on the variables that are reachable from the start symbol 
\begin_inset Formula $S$
\end_inset

 and the productions that envolve the symbols of those that were discovered.
 Variables not discovered can then be eliminated.
\end_layout

\begin_layout Subsubsection
Elimininating Epilson Productions
\begin_inset CommandInset label
LatexCommand label
name "subsec:elimininatingEpilsonProduction"

\end_inset


\end_layout

\begin_layout Standard
Epsilon prodcutions are of the form 
\begin_inset Formula $A\rightarrow\epsilon$
\end_inset

.
 These productions can be eliminated from the grammar, however in doing
 so the grammar loses the ability to represent the empty string.
 To eliminate epsilon productions we need to discover the nullable symbols
 of the grammar.
 A nullable symbol is a symbol that eventually derives the empty string
 (i.e.
 A
\begin_inset Formula $\Rightarrow^{*}\epsilon$
\end_inset

 ).
 The following inductive argument can be used to discover nullable symbols.
 The basis is obviously if a production directly derives epsilon as in 
\begin_inset Formula $A\rightarrow\epsilon$
\end_inset

, then it is a nullable symbol.
 The induction then becomes, if there is a production 
\begin_inset Formula $A\rightarrow\alpha$
\end_inset

, in which all the symbols of 
\begin_inset Formula $\alpha$
\end_inset

eventulay derive epsilon then the production is nullable.
 
\end_layout

\begin_layout Subsubsection
Eliminating Unit Productions
\begin_inset CommandInset label
LatexCommand label
name "subsec:eliminatingUnitProductions"

\end_inset


\end_layout

\begin_layout Standard
Unit productions are productions whose body consist of a single variable.
 The key idea is that if a variable 
\begin_inset Formula $A$
\end_inset

 eventually derives a variable single variable 
\begin_inset Formula $B$
\end_inset

 by a series of unit productions, and 
\begin_inset Formula $B$
\end_inset

derives the production 
\begin_inset Formula $B\rightarrow\alpha$
\end_inset

, then we can rewite 
\begin_inset Formula $A$
\end_inset

 as the production 
\begin_inset Formula $A\rightarrow\alpha$
\end_inset

 and drop all the intermediate unit productions.
 The algorithm to discover unit productions is as follows: Find all pairs
 of variables 
\begin_inset Formula $(A,B)$
\end_inset

 such that 
\begin_inset Formula $A\Rightarrow^{*}B$
\end_inset

 by a sequence of unit production only.
 The induction has the basis 
\begin_inset Formula $(A,A)$
\end_inset

 and the IH if we have found 
\begin_inset Formula $(A,B)$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 derives 
\begin_inset Formula $C$
\end_inset

, then 
\begin_inset Formula $A$
\end_inset

 derives 
\begin_inset Formula $C$
\end_inset

 and so they form the pair 
\begin_inset Formula $(A,C).$
\end_inset


\end_layout

\begin_layout Subsubsection
Representing Grammars in Chomsky Normal Form (CNF)
\begin_inset CommandInset label
LatexCommand label
name "subsec:representingGrammarsInChomskyNormalForm"

\end_inset


\end_layout

\begin_layout Standard
Context free grammars in Chomsky Normal Formal are restricted to productions
 of two types:
\end_layout

\begin_layout Itemize
Productions with two variables (
\begin_inset Formula $A\rightarrow BC).$
\end_inset


\end_layout

\begin_layout Itemize
Productions with a single terminal (
\begin_inset Formula $A\rightarrow a).$
\end_inset


\end_layout

\begin_layout Standard
Theorem: If a language 
\begin_inset Formula $L$
\end_inset

 is a context free language, then the language with all epsilon productions
 eliminated has a context free grammar in Chomsky Normal Form.
 Forming the CFG such that it is in CNF can be carried out by cleaning up
 the grammar as descibed in the subsections
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:elimininatingEpilsonProduction"

\end_inset

,
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:eliminatingUnitProductions"

\end_inset

, and 
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:eliminatingUselessVariables"

\end_inset

.
 
\end_layout

\begin_layout Section
Pushdown Automata
\begin_inset CommandInset label
LatexCommand label
name "sec:Pushdown-Automata"

\end_inset


\end_layout

\begin_layout Standard
A pushdown automata(PDA) is equivalent in power to a context free grammar
 (CFG) in that any language defined in terms of a CFG can be equally defined
 in terms of a PDA.
 Traditionally, when speaking about PDA's we mean the nondeterministic type
 (NPDA).
 NPDA's are more powerful than their deterministic counterparts.
 Intuitively speaking a PDA is like an 
\begin_inset Formula $\epsilon-$
\end_inset

NFA with the additional power of manipulating a stack.
 The computation of the PDA is controlled by the state of its 
\begin_inset Formula $\epsilon-$
\end_inset

NFA, the input symbol to be processed, and finally the symbol on top of
 its stack.
 Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:pushdownAutomata"

\end_inset

.
 In addition to transition to a new state, the PDA may push or pop symbols
 off of the stack.
 PDA's are typically described by the following components 
\begin_inset Formula $Q$
\end_inset

 a finite set of states, 
\begin_inset Formula $\Sigma$
\end_inset

 an input alphabet, 
\begin_inset Formula $\Gamma$
\end_inset

 a stack alphabet, 
\begin_inset Formula $\delta$
\end_inset

 a transistion function, 
\begin_inset Formula $q_{0}$
\end_inset

 a start state,
\begin_inset Formula $z_{0}$
\end_inset

 a stack start symbol, and a set of final states 
\begin_inset Formula $F\subseteq Q$
\end_inset

 .
 The transition function 
\begin_inset Formula $\delta$
\end_inset

 is parameterized by three components: a state in 
\begin_inset Formula $Q$
\end_inset

, an input symbol in 
\begin_inset Formula $\Sigma$
\end_inset

, and a stack symbol in 
\begin_inset Formula $\Gamma$
\end_inset

 (e.g.
 
\begin_inset Formula $\delta(q_{0},a,Z)$
\end_inset

).
 The 
\begin_inset Formula $\delta$
\end_inset

 of given parameters yields a set of tuples containing a state to transition
 to and a symbol to manipulate the stack 
\begin_inset Formula $\left(p,a\right)$
\end_inset

.
 Here 
\begin_inset Formula $p$
\end_inset

 represents the next state and 
\begin_inset Formula $a$
\end_inset

is a string of stack symbols possibly empty.
 
\end_layout

\begin_layout Subsection
Conventional Usage of Pushdown Automata
\begin_inset CommandInset label
LatexCommand label
name "subsec:conventionalUsageOfPDA"

\end_inset


\end_layout

\begin_layout Standard
Lowercase letters at the beginning of the alphabet (e.g.
 a, b, c, and 
\begin_inset Formula $\epsilon$
\end_inset

) are used as input symbols.
 Capital letters at the end of the alphabet are used as stack symbols (e.g.
 X, Y, and Z).
 Lowercase letters at the end of the alphabet (e.g.
 w,x,y, and z) are used as strings of input symbols.
 Greek letters are used as strings of stack symbols (e.g.
 
\begin_inset Formula $\alpha,\beta$
\end_inset

 and 
\begin_inset Formula $\gamma)$
\end_inset

 are strings of stack symbols.
 An example of a PDA modeling the language 
\begin_inset Formula $L=\{0^{n}1^{n}|n\geq1\}$
\end_inset

 is given in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:pdaExample"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Instantaneous Descriptions and the Goes-To Relation
\begin_inset CommandInset label
LatexCommand label
name "subsec:instantaneousDescriptionsAndGoesToRelation"

\end_inset


\end_layout

\begin_layout Standard
An instantaneous description(ID) of a PDA is like a snapshot of a PDA as
 it computes.
 Each sucessesive step in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:pdaExample"

\end_inset

 has a corresponding instantaeous description triple describing the current
 state 
\begin_inset Formula $q$
\end_inset

, the remaining input 
\begin_inset Formula $w,$
\end_inset

and the contents of the stack 
\begin_inset Formula $a$
\end_inset

.
 The vertical dash symbol, 
\begin_inset Formula $\vdash$
\end_inset

, represents the Goes-To relation.
 The relation means that for a specified ID I a tranistion to ID J is possible
 in one step.
 For example if the transition function 
\begin_inset Formula $\delta(q,a,X)$
\end_inset

 yields 
\begin_inset Formula $\left(p,\beta\right)$
\end_inset

 the we may specify the Goes-To relation as 
\begin_inset Formula $(q,aw,Xa)\vdash(p,w,\beta\alpha)$
\end_inset

.
 Similiarly, the 
\begin_inset Formula $\vdash^{*}$
\end_inset

 means the transition occurs in zero or more steps.
\end_layout

\begin_layout Subsection
PDA Language Descriptions
\begin_inset CommandInset label
LatexCommand label
name "subsec:PDALanguageDescriptions"

\end_inset


\end_layout

\begin_layout Standard
The languages of PDA's are defined by 
\begin_inset Formula $L(P)$
\end_inset

 for the set of strings 
\begin_inset Formula $w$
\end_inset

 such that for the ID 
\begin_inset Formula $(q_{0},w,Z)$
\end_inset


\begin_inset Formula $\vdash^{*}$
\end_inset


\begin_inset Formula $(f,\epsilon,\alpha)$
\end_inset

 for the final state 
\begin_inset Formula $f$
\end_inset

 and the stack string 
\begin_inset Formula $a$
\end_inset

.
 This is the set of strings 
\begin_inset Formula $w$
\end_inset

 that are consumed by the PDA such that only the empy string, 
\begin_inset Formula $\epsilon,$
\end_inset

 is left in the final state.
 The notation 
\begin_inset Formula $N(P)$
\end_inset

 for a given PDA 
\begin_inset Formula $P$
\end_inset

 describes the PDA's language when the stack becomes empty.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/pushdownAutomata.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pushdownAutomata"

\end_inset

 Three elements control how a PDA will compute: the input, the state, and
 the stack
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/pdaExample.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pdaExample"

\end_inset

The computation shows the evolution of the PDA's stack, input and state
 as the string is processed.
 The initial starting state is shown on the left and the final accepting
 state is shown on the right.
 The following transitions define the behavior: 
\begin_inset Formula $\delta(q,0,Z)=\{(q,XZ)\}$
\end_inset

, 
\begin_inset Formula $\delta(q,0,X)=\{(q,XX)\}$
\end_inset

, 
\begin_inset Formula $\delta(q,1,X)=\{(p,\epsilon)\}$
\end_inset

, 
\begin_inset Formula $\delta(p,1,X)=\{(p,\epsilon)\}$
\end_inset

, 
\begin_inset Formula $\delta(p,\epsilon,Z)=\{(f,Z)\}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Equivalence of CFG's and PDA's
\begin_inset CommandInset label
LatexCommand label
name "sec:equivalenceCFGPDA"

\end_inset


\end_layout

\begin_layout Subsection
Converting CFG's 
\begin_inset Formula $\Rightarrow$
\end_inset

 PDA's
\begin_inset CommandInset label
LatexCommand label
name "subsec:Converting-CFG's-"

\end_inset


\end_layout

\begin_layout Standard
For some grammar 
\begin_inset Formula $G$
\end_inset

, let the language 
\begin_inset Formula $L=L(G).$
\end_inset

 We construct the PDA P such that upon emptying the stack we obtain a string
 in the language 
\begin_inset Formula $L$
\end_inset

 (i.e.
 
\begin_inset Formula $N(P)=L$
\end_inset

).
 P has one state 
\begin_inset Formula $q.$
\end_inset

 The terminals of the grammar G become the input symbols 
\begin_inset Formula $\Sigma$
\end_inset

 of the PDA 
\begin_inset Formula $P$
\end_inset

.
 The variables and terminals of G make up the stack symbols 
\begin_inset Formula $\Gamma$
\end_inset

 of the 
\begin_inset Formula $P$
\end_inset

.
 The start symbol of 
\begin_inset Formula $G$
\end_inset

 becomes the start symbol of 
\begin_inset Formula $P.$
\end_inset

 Intutitively, we must model the left sentential form of a grammar with
 the PDA.
 If the stack of the PDA 
\begin_inset Formula $P$
\end_inset

 is 
\begin_inset Formula $a,$
\end_inset

 and 
\begin_inset Formula $P$
\end_inset

has so far consumed 
\begin_inset Formula $x$
\end_inset

from its input, then 
\begin_inset Formula $P$
\end_inset

 represents the left-sentential form 
\begin_inset Formula $xa$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Creating the Transition Function
\begin_inset CommandInset label
LatexCommand label
name "subsec:creatingTheTransitionFunction"

\end_inset


\end_layout

\begin_layout Standard
There are two kinds of rules in the transition function of P, depending
 on whether a terminal or variable of G is at the top of P’s stack.
 The 
\emph on
type-1
\emph default
 rules handle the case where “a” is the terminal on top of P’s stack (
\begin_inset Formula $\delta(q,a,a)=(q,\epsilon))$
\end_inset

.
 There better be an “a” as the next input symbol, or P has guessed wrongly
 about the leftmost derivation of the input as it actually exists.
 In effect, we “cancel” the “a” on the stack against the “a” on the input.
 The left-sentential form represented does not change.
 We have now consumed one more symbol, “a”, from the input so that becomes
 part of the left-sentiantial form.
 But the “a” that was on the stack is removed, so it no longer participates
 in the left-sentential form.
 The 
\emph on
type-2
\emph default
 rules handle a variable, say 
\begin_inset Formula $A$
\end_inset

, on the top of the stack (
\begin_inset Formula $\delta(q,\epsilon,A)=(q,a))$
\end_inset

.
 We need to expand that variable by the body of one of its productions,
 and thus move to the next left-sentential form.
 Of course we’re only guessing.
 We have to allow any of 
\begin_inset Formula $A's$
\end_inset

 productions to be used.
 If 
\begin_inset Formula $A\rightarrow a$
\end_inset

 is one of these productions, then a choice for 
\begin_inset Formula $P$
\end_inset

, using epsilon input, and with 
\begin_inset Formula $A$
\end_inset

 on top of the stack, is to replace the 
\begin_inset Formula $A$
\end_inset

 by 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Proof of Equivalence between CFG and PDA
\begin_inset CommandInset label
LatexCommand label
name "subsec:proofEquivalenceCFGPDA"

\end_inset


\end_layout

\begin_layout Standard
In order to prove equivalence between the two representations we need to
 prove that for all 
\begin_inset Formula $x,$
\end_inset


\begin_inset Formula $(q,wx,S)\vdash^{*}(q,x,\alpha)\leftrightarrow S\Rightarrow_{lm}^{*}w\alpha$
\end_inset

.
 That is, for all x the instantaneous decription 
\begin_inset Formula $(q,wx,S)$
\end_inset

 goes to 
\begin_inset Formula $(q,x,\alpha)$
\end_inset

 in some number of steps of the PDA if and only if the CFG's leftmost derivation
 yields 
\begin_inset Formula $w\alpha$
\end_inset

.
 It is important to note that we allow for the suffix 
\begin_inset Formula $x$
\end_inset

in the string 
\begin_inset Formula $wx$
\end_inset

.
 The string 
\begin_inset Formula $x$
\end_inset

 has no effect on the process of consuming 
\begin_inset Formula $w$
\end_inset

 and so if the that statement is true for one 
\begin_inset Formula $x$
\end_inset

it is true for all 
\begin_inset Formula $x.$
\end_inset

 The proof follow starting from the only if direction 
\begin_inset Formula $(\rightarrow)$
\end_inset

.
 That is, if P transitions 
\begin_inset Formula $(q,wx,S)$
\end_inset

 goes to 
\begin_inset Formula $(q,x,\alpha)$
\end_inset

, then 
\begin_inset Formula $S\Rightarrow_{lm}^{*}w\alpha$
\end_inset

.
 This will be an inductive proof where the base case is 0 steps have taken
 place and 
\begin_inset Formula $w$
\end_inset

 is 
\begin_inset Formula $\epsilon$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

is 
\begin_inset Formula $S$
\end_inset

.
 The truth of the base case becomes trivial because 
\begin_inset Formula $S$
\end_inset

 is 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $w\alpha$
\end_inset

 is just 
\begin_inset Formula $\alpha$
\end_inset

 because 
\begin_inset Formula $\epsilon$
\end_inset

 serves as the identity of concatenation.
 Surely then, 
\begin_inset Formula $S$
\end_inset

 derives itself.
 Now we must consider the next 
\begin_inset Formula $n$
\end_inset

 steps of the proof, and assume an inductive hypothesis for the sequence
 of 
\begin_inset Formula $n-1$
\end_inset

 steps.
 For the 
\begin_inset Formula $n^{th}$
\end_inset

 step two cases can occur.
 A type-1 rule is used, or a type 2 rule is used.
 We will consider both case in turn.
 The descriptions of these rules are described in the previous subsection.
 For the use of a 
\emph on
type-1 
\emph default
rule in the 
\begin_inset Formula $n^{th}$
\end_inset

 step, the ID's for the 0 through 
\begin_inset Formula $n-1$
\end_inset

 steps must be 
\begin_inset Formula $(q,yax,S)\vdash^{*}(q,ax,a\alpha)\vdash(q,x,\alpha)$
\end_inset

, where 
\begin_inset Formula $ya=w$
\end_inset

.
 That is, the prefix of the string 
\begin_inset Formula $x$
\end_inset

must end with the symbol 
\begin_inset Formula $a$
\end_inset

 with the 
\begin_inset Formula $a$
\end_inset

 symbol on top of the stack followed by 
\begin_inset Formula $\alpha$
\end_inset

, and in the previous 
\begin_inset Formula $n-1$
\end_inset

 steps the string 
\begin_inset Formula $y$
\end_inset

 is consumed by the PDA, and in the 
\begin_inset Formula $n^{th}$
\end_inset

 step the PDA consumes the input symbol 
\begin_inset Formula $a$
\end_inset

 and removes it from the stack.
 By the inductive hypothesis applied to the 
\begin_inset Formula $n-1$
\end_inset

 steps, we can conlude that there is a left most derivation from 
\begin_inset Formula $S$
\end_inset

 to 
\begin_inset Formula $ya\alpha$
\end_inset

 because y was consumed and thus equivalent to 
\begin_inset Formula $\epsilon$
\end_inset

and 
\begin_inset Formula $a\alpha$
\end_inset

 is on the stack.
 The symbol 
\begin_inset Formula $a$
\end_inset

is then consumed from the input and popped from stack taking us back to
 the base case because 
\begin_inset Formula $ya=w$
\end_inset

.
 For the use of a 
\emph on
type-2 
\emph default
rule in the 
\begin_inset Formula $n^{th}$
\end_inset

 step, the step sequence must be 
\begin_inset Formula $(q,wx,S)\vdash^{*}(q,x,A\beta)\vdash(q,x,\gamma\beta)$
\end_inset

 where 
\begin_inset Formula $A\rightarrow\gamma$
\end_inset

 is a production in the grammar and 
\begin_inset Formula $\alpha=\gamma\beta$
\end_inset

.
 In this case, we have a variable 
\begin_inset Formula $A$
\end_inset

 on top of the stack followed by the stack string 
\begin_inset Formula $\beta$
\end_inset

.
 In the 
\begin_inset Formula $n^{th}$
\end_inset

 step no input is consumed but the variable 
\begin_inset Formula $A$
\end_inset

 is replaced by the stack string 
\begin_inset Formula $\gamma$
\end_inset

.
 By the inductive hypothesis we obtain 
\begin_inset Formula $S\Rightarrow_{lm}^{*}wA\beta$
\end_inset

 after the first 
\begin_inset Formula $n-1$
\end_inset

 steps.
 Because 
\begin_inset Formula $A$
\end_inset

 is the leftmost variable in the derivation it is replaced by 
\begin_inset Formula $\gamma$
\end_inset

.
 We then have 
\begin_inset Formula $S\Rightarrow_{lm}^{*}w\gamma\beta=w\alpha$
\end_inset

 returning us to our base case, thus proving the only if direction of the
 proof.
 Next, we prove the if direction (
\begin_inset Formula $\leftarrow)$
\end_inset

.
 We now must prove 
\begin_inset Formula $S\Rightarrow_{lm}^{*}w\alpha\rightarrow(q,wx,S)\vdash^{*}(q,x,\alpha)$
\end_inset

 for all 
\begin_inset Formula $x$
\end_inset

 
\begin_inset Formula $\ldots$
\end_inset

[ommited]
\end_layout

\begin_layout Subsection
Converting PDA's 
\begin_inset Formula $\Rightarrow$
\end_inset

 CFG's
\begin_inset CommandInset label
LatexCommand label
name "subsec:convertingPDA2CFG"

\end_inset


\end_layout

\begin_layout Standard
In this section we obtain the grammar 
\begin_inset Formula $G$
\end_inset

 from a PDA 
\begin_inset Formula $P$
\end_inset

.
 We assume that the language 
\begin_inset Formula $L$
\end_inset

 is accepted by the PDA upon emptying its stack, more formally 
\begin_inset Formula $L=N(P).$
\end_inset

 Intuitively, we should assign variables labled as 
\begin_inset Formula $pXq$
\end_inset

 to the grammar 
\begin_inset Formula $G$
\end_inset

 for the transitions from state 
\begin_inset Formula $p$
\end_inset

to state 
\begin_inset Formula $q$
\end_inset

when popping the symbol 
\begin_inset Formula $X$
\end_inset

 from the PDA's stack.
 Upon popping the 
\begin_inset Formula $X$
\end_inset

 from the stack it may grow, but the stack size will not shrink below the
 size when 
\begin_inset Formula $X$
\end_inset

 was popped off the stack until the last step in processing is taken.
\end_layout

\begin_layout Subsubsection
Constructing Variables of the CFG
\begin_inset CommandInset label
LatexCommand label
name "subsec:constructingVariablesOfCFG"

\end_inset


\end_layout

\begin_layout Standard
The variables of 
\begin_inset Formula $G$
\end_inset

 are correspond to labels such as 
\begin_inset Formula $pXq$
\end_inset

 which can be viewed as a single symbol modeling the transition from p to
 q with X on the stack in which the input is consumed and generates all
 and only the strings 
\begin_inset Formula $w$
\end_inset

 until 
\begin_inset Formula $\left(p,w,X\right)\vdash^{*}(q,\epsilon,\epsilon)$
\end_inset

.
 Note that since the initial ID shows nothing below 
\begin_inset Formula $X$
\end_inset

 on the stack, we know that 
\begin_inset Formula $X$
\end_inset

 can’t be popped until the last step, since PDA P cannot make any moves
 when its stack is empty.In addition to the aforementioned variable a start
 symbol 
\begin_inset Formula $S$
\end_inset

 is needed.
\end_layout

\begin_layout Subsubsection
Constructing Productions of the CFG
\begin_inset CommandInset label
LatexCommand label
name "subsec:constructingProductionsOfCFG"

\end_inset


\end_layout

\begin_layout Standard
Intuitively, the productions or rules of the grammar represent steps of
 the PDA.
 Each rule for the example rule 
\begin_inset Formula $pXq$
\end_inset

 is sourced from the PDA in state 
\begin_inset Formula $p$
\end_inset

with the stack symbol 
\begin_inset Formula $X$
\end_inset

.
 In the easiest case we have the following for the PDA's transition function.
 
\begin_inset Formula $\delta(p,a,X)$
\end_inset

 yields 
\begin_inset Formula $(p,\epsilon)$
\end_inset

.
 Here 
\begin_inset Formula $a$
\end_inset

 denotes either a input symbol or 
\begin_inset Formula $\epsilon$
\end_inset

.
 The grammar in this case can model the PDA's behavior by popping 
\begin_inset Formula $X$
\end_inset

and not replacing it with any other symbol 
\begin_inset Formula $(pXq\rightarrow a)$
\end_inset

.
 The next simplest case simplest case involves modeling transition between
 productions.
 Transitivy is modeled by introducing an intermediate state 
\begin_inset Formula $r$
\end_inset

and a variable 
\begin_inset Formula $Y$
\end_inset

.
 The transition function in this case would look like 
\begin_inset Formula $\delta(p,a,X)$
\end_inset

 yields 
\begin_inset Formula $(r,Y)$
\end_inset

.
 The corresponding production would then be 
\begin_inset Formula $pXq\rightarrow arYq$
\end_inset

.
 This allows us to erase X and transition from 
\begin_inset Formula $p$
\end_inset

 to 
\begin_inset Formula $q$
\end_inset

 by way of 
\begin_inset Formula $r$
\end_inset

 while reading 
\begin_inset Formula $a$
\end_inset

and pushing 
\begin_inset Formula $Y$
\end_inset

 onto the stack.
 The final simplest case we will consider is 
\begin_inset Formula $\delta(p,a,X)$
\end_inset

 yields 
\begin_inset Formula $(r,YZ)$
\end_inset

 for some state 
\begin_inset Formula $r$
\end_inset

 and some symbols 
\begin_inset Formula $Y$
\end_inset

and 
\begin_inset Formula $Z$
\end_inset

.
 Here 
\begin_inset Formula $X$
\end_inset

 is replaced by 
\begin_inset Formula $YZ$
\end_inset

.
 In order for 
\begin_inset Formula $X$
\end_inset

 to be erased, there must be some input string u that has the net effect
 of erasing 
\begin_inset Formula $Y$
\end_inset

.
 And 
\begin_inset Formula $u$
\end_inset

 must take the PDA from state 
\begin_inset Formula $r$
\end_inset

 to some state 
\begin_inset Formula $s$
\end_inset

, which we don’t know.
 As a result, we’re going to have to have one production for each state
 
\begin_inset Formula $s$
\end_inset

.
 But after reaching state 
\begin_inset Formula $s$
\end_inset

, we must have some additional input 
\begin_inset Formula $v$
\end_inset

 that takes the PDA from state 
\begin_inset Formula $s$
\end_inset

 to state 
\begin_inset Formula $q$
\end_inset

, while popping the 
\begin_inset Formula $Z$
\end_inset

 from the stack.
 The net effect is that
\begin_inset Formula $auv$
\end_inset

 pops 
\begin_inset Formula $X$
\end_inset

 from the stack while going from state 
\begin_inset Formula $p$
\end_inset

 to 
\begin_inset Formula $q.$
\end_inset

 The general case for creating productions to model the PDA follows.
 Suppose 
\begin_inset Formula $\delta(p,a,X)$
\end_inset

 yields 
\begin_inset Formula $(r,Y_{1},\ldots Y_{k})$
\end_inset

 for some state 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $k\geq3.$
\end_inset

 Then in the grammar generate the set of productions 
\begin_inset Formula $pXq\rightarrow arY_{1}s_{1}s_{1}Y_{2}s_{2}\ldots s_{k-2}Y_{k-1}s_{k-1}s_{k-1}Y_{k}q$
\end_inset

.
 This models the case in which 
\begin_inset Formula $X$
\end_inset

 is replaced by three or more symbols transitioning from 
\begin_inset Formula $p$
\end_inset

 to 
\begin_inset Formula $q.$
\end_inset


\end_layout

\begin_layout Section
Pumping Lemma for Context Free Languages
\begin_inset CommandInset label
LatexCommand label
name "sec:pumpingLemmaForContextFreeLanguages"

\end_inset


\end_layout

\begin_layout Standard
Recall the concepts for the pumping lemma on regular languages outlined
 in Section
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:pumpingLemmaRegularLanguages"

\end_inset

.
 The pumping lemma for regular languages relied on a cycle early on in a
 sufficiently long string 
\begin_inset Formula $w$
\end_inset

 in order 
\begin_inset Quotes eld
\end_inset

pump
\begin_inset Quotes erd
\end_inset

 an the string an arbitrary number of times, thus producing a infinite number
 of strings in the language.
 Similiarly, the pumping lemma for context free languages models this idea,
 but requires two cycles along the string's path in tandem.
 
\end_layout

\begin_layout Subsection
Formal Specification of the CFL Pumping Lemma
\begin_inset CommandInset label
LatexCommand label
name "subsec:formalSpecificationOfContextFreeLanguages"

\end_inset


\end_layout

\begin_layout Standard
For every context free language 
\begin_inset Formula $L$
\end_inset

, there is an integer 
\begin_inset Formula $n$
\end_inset

, such that for every string 
\begin_inset Formula $z$
\end_inset

 in 
\begin_inset Formula $L$
\end_inset

 of length 
\begin_inset Formula $\geq n$
\end_inset

 there exists 
\begin_inset Formula $z=uvwxy$
\end_inset

 such that the following conditions hold:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $|vwx|\leq n.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $|vx|>0.$
\end_inset


\end_layout

\begin_layout Enumerate
For all 
\begin_inset Formula $i\geq0$
\end_inset

, 
\begin_inset Formula $uv^{i}wx^{i}y$
\end_inset

 is in 
\begin_inset Formula $L.$
\end_inset


\end_layout

\begin_layout Standard
If a language in question does not have these properties, then it is not
 a context free language.
\end_layout

\begin_layout Section
Properties of Context Free Languages
\begin_inset CommandInset label
LatexCommand label
name "sec:propertiesOfContextFreeLanguages"

\end_inset


\end_layout

\begin_layout Subsection
Decision Properties of Context Free Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:decisionPropertiesOfContextFreeLanguages"

\end_inset


\end_layout

\begin_layout Standard
Like regular languages we can determine many decision properties about context
 free languages including whether a string in the particular CFL, whether
 a CFL contains any strings at all, and if the CFL contains an infinite
 number of strings.
 Unfortunately,we cannot decide whether two CFL's are equivalent, or whether
 they are disjoint.
\end_layout

\begin_layout Subsubsection
Membership Test for CFL's
\begin_inset CommandInset label
LatexCommand label
name "subsec:membershipTestForCFL"

\end_inset


\end_layout

\begin_layout Standard
The membership test is used to determine whether a given string 
\begin_inset Formula $w$
\end_inset

 is the language of the grammar 
\begin_inset Formula $L(G).$
\end_inset

 We need the grammar to be in Chomsky Normal Form, so if it isn't then convert
 it to this form as described in subsection
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:representingGrammarsInChomskyNormalForm"

\end_inset

.
 Then use the CYK algorithm to determine the status of 
\begin_inset Formula $w.$
\end_inset

 The CYK algorithm uses Dynamic Programming to decide whether 
\begin_inset Formula $w$
\end_inset

 is in the language or not, so it may be useful to first review the section
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Dynamic-Programming"

\end_inset

 first in order to gain better understanding of CYK.
\end_layout

\begin_layout Subsubsection
The CYK ALgorithm
\end_layout

\begin_layout Standard
\align left
Let 
\begin_inset Formula $w=a_{0}\ldots a_{n}$
\end_inset

 be a string of length 
\begin_inset Formula $n$
\end_inset

where 
\begin_inset Formula $a_{i}$
\end_inset

 stores the symbol at the 
\begin_inset Formula $i^{th}$
\end_inset

 position.
 Construct a 
\begin_inset Formula $n$
\end_inset

 by 
\begin_inset Formula $n$
\end_inset

 triangular array.
 This can done efficiently by using an indexing function where upon a single-ind
exed array is mapped to an upper-triangular array.
 The following function 
\begin_inset Formula $k=j(j+1)/2+i$
\end_inset

 where 
\begin_inset Formula $k$
\end_inset

 represents the index into the array properly maps the elements of the array.
 This idea can be viewed in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:triangularArray"

\end_inset

.
 Additionaly, each entry of the array should be viewed as a set of variables
 of the grammar.
 The set 
\begin_inset Formula $X_{ij}$
\end_inset

 is stored in position 
\begin_inset Formula $(i,j)$
\end_inset

 of the array where 
\begin_inset Formula $i\leq j$
\end_inset

 and is inteded to be the set of variables that derive the substring of
 the input starting from position 
\begin_inset Formula $i$
\end_inset

 and ending at position 
\begin_inset Formula $j$
\end_inset

.
 An inductive argument is used to fill the table on the length of the input
 string derived .
 The length of the string can be computed as 
\begin_inset Formula $j-i+1$
\end_inset

.
 We start by computing the entries 
\begin_inset Formula $X_{i,i}$
\end_inset

, which is the set of variables that derive the string consisting of the
 symbol at 
\begin_inset Formula $a_{i}$
\end_inset

 .
 Next, we find the variables at 
\begin_inset Formula $X_{i,i+1}$
\end_inset

 each of which derive the string at 
\begin_inset Formula $a_{i,i+1}$
\end_inset

.
 Then, we move to the 
\begin_inset Formula $X_{i,i+2}$
\end_inset

 variables which are the sets of variables that derive the strings of length
 three, 
\begin_inset Formula $a_{i},$
\end_inset


\begin_inset Formula $a_{i+1},$
\end_inset


\begin_inset Formula $a_{i+2}$
\end_inset

 and so on .
 Finally, after we have computed the set 
\begin_inset Formula $X_{1,n}$
\end_inset

 which represents the entire input string , we can test whether the start
 symbol 
\begin_inset Formula $S$
\end_inset

 is contained in the set .
 If it is then the string is in the language, otherwise it is not.
 Formally, the basis 
\begin_inset Formula $X_{i,i}=\{A|A\Rightarrow^{*}a_{i}\}$
\end_inset

 where 
\begin_inset Formula $a_{i}$
\end_inset

 represents a single symbol in 
\begin_inset Formula $w$
\end_inset

.
 The induction is then 
\begin_inset Formula $X_{i,j}$
\end_inset

={A| there is a production 
\begin_inset Formula $A\rightarrow BC$
\end_inset

, and an integer 
\begin_inset Formula $k$
\end_inset

, with 
\begin_inset Formula $i\leq k<j$
\end_inset

, such that 
\begin_inset Formula $B$
\end_inset

 is in 
\begin_inset Formula $X_{i,k}$
\end_inset

 and 
\begin_inset Formula $C$
\end_inset

 is in 
\begin_inset Formula $X_{k+1,j}$
\end_inset

}.That is, for each 
\begin_inset Formula $k$
\end_inset

 between 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j-1$
\end_inset

 we look for some 
\begin_inset Formula $B$
\end_inset

 in 
\begin_inset Formula $X_{i,k}$
\end_inset

 and some 
\begin_inset Formula $C$
\end_inset

 in 
\begin_inset Formula $X_{k+1,j}$
\end_inset

 such that 
\begin_inset Formula $BC$
\end_inset

 is the body of an 
\begin_inset Formula $A$
\end_inset

 production.
 If for any 
\begin_inset Formula $k$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, and 
\begin_inset Formula $C$
\end_inset

 we find such a production, we add 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $X_{i,j}$
\end_inset

.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="decimal" decimal_point="." valignment="top">
<column alignment="decimal" decimal_point="." valignment="top">
<column alignment="decimal" decimal_point="." valignment="top">
<column alignment="decimal" decimal_point="." valignment="top" width="0pt">
<row>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:triangularArray"

\end_inset

A single index array can be viewed as a triangular array by accessing it
 with a function mapping the rows and columns appropriately.
 The function 
\begin_inset Formula $k=j(j+1)/2+i$
\end_inset

 maps the index value 
\begin_inset Formula $k$
\end_inset

 to the appropriate 
\begin_inset Formula $i$
\end_inset

 and column 
\begin_inset Formula $j$
\end_inset

 where 
\begin_inset Formula $i\leq j$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Emptiness Test for CFL's
\begin_inset CommandInset label
LatexCommand label
name "subsec:emptinessTestForCFL"

\end_inset


\end_layout

\begin_layout Standard
The algorithim to test for an empty CFL uses the ideas we learned in subsection
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:eliminatingUselessVariables"

\end_inset

.
 We use these ideas of checking whether variables are useful in the derivation
 to determine if the start symbol 
\begin_inset Formula $S$
\end_inset

 is a useful symbol.
 If the start symbol does not derive anything, it is a useless variable,
 and we can state that the CFL is empty.
 
\end_layout

\begin_layout Subsubsection
Infiniteness Test for CFL's
\begin_inset CommandInset label
LatexCommand label
name "subsec:infinitenessTestCFL"

\end_inset


\end_layout

\begin_layout Standard
The test for infinteness in CFL mirrors the idea that was proposed in section
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:infinitenessTestRegularLanguages"

\end_inset

.
 Apply those priniciples with the pumping lemma for context free languages
 outlined in section
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:pumpingLemmaForContextFreeLanguages"

\end_inset

.
\end_layout

\begin_layout Subsection
Closure Properties of Context Free Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:closurePropertiesOfContextFreeLanguages"

\end_inset


\end_layout

\begin_layout Standard
For many of the same operations under which the class of regular languages
 are closed, the context-free languages are also closed.
 These include the regular-expression operations: union, concatenation,
 and closure.
 Also reversal, homomorphism and inverse homomorphism.
 But unlike the class of regular languages, the class of context-free languages
 is not closed under intersection or difference.
 
\end_layout

\begin_layout Subsubsection
Union for CFL's
\begin_inset CommandInset label
LatexCommand label
name "subsec:unionForCFL's"

\end_inset


\end_layout

\begin_layout Standard
//TODO
\end_layout

\begin_layout Subsubsection
Concatentation for CFL's
\begin_inset CommandInset label
LatexCommand label
name "subsec:concatentationForCFL's"

\end_inset


\end_layout

\begin_layout Standard
//TODO
\end_layout

\begin_layout Subsubsection
Kleene Closure for CFL's
\begin_inset CommandInset label
LatexCommand label
name "subsec:kleeneClosureForCFL's"

\end_inset


\end_layout

\begin_layout Standard
//TODO
\end_layout

\begin_layout Section
Countability
\begin_inset CommandInset label
LatexCommand label
name "sec:Countability"

\end_inset


\end_layout

\begin_layout Standard
It is important to understand that all computation can be encoded as integers.
 The ascii or if you like the UTF-8 table encodes english characters and
 algebraic numerals, which we can interpret as integers.
 This idea can be applied to all types of media.
 At the very root we may interpret all things as integers.
\end_layout

\begin_layout Subsection
Finite Sets
\end_layout

\begin_layout Standard
A finite set is a set that contains a finite number of elements.
 Refer to Section
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Sets"

\end_inset

.
 It may be useful to refresh your memory on this topic.
 The formal definition of a finite set is one for which it is impossible
 to find a one to one correspondence between the members of the set and
 a proper subset of the set.
 An example of a set is 
\begin_inset Formula $\{a,b,c\}.$
\end_inset


\end_layout

\begin_layout Subsection
Infinite Sets
\end_layout

\begin_layout Standard
An infinite set is a set for which there is a one to one correspondence
 between itself and a proper subset of itself.
 An example of a infinite set is the positive integers 
\begin_inset Formula $\{1,2,3,\ldots\}.$
\end_inset

 The one-to-one correspondence which validates this argument is the mapping
 of the positive integers with the even integers ( 
\begin_inset Formula $1\leftrightarrow2,2\leftrightarrow4,3\leftrightarrow6,\ldots)$
\end_inset

.
\end_layout

\begin_layout Subsection
Countable Sets
\end_layout

\begin_layout Standard
A countable set is a set with a one to one correspondence with the positive
 integers, thus all countable sets are infinite sets.
 As another example all integers 
\begin_inset Formula $\mathbb{Z}$
\end_inset

 form a countable set.
 0 is mapped to 1 and the negative integers are are mapped to the even numbers
 (
\begin_inset Formula $-i\leftrightarrow2i$
\end_inset

, for all 
\begin_inset Formula $i\geq1$
\end_inset

), while the positive integers are mapped to odd numbers
\begin_inset Formula $(i\leftrightarrow2i+1$
\end_inset

, for all 
\begin_inset Formula $i\geq1$
\end_inset

).
 The enumerated sequence then becomes 
\begin_inset Formula $0,-1,1,-2,2,-3,3,\ldots$
\end_inset

 Another example of an enumerable set is the binary strings, but there is
 a trick involved.
 The binary strings 
\begin_inset Formula $101,0101,00101$
\end_inset

 all coorespond to the integer value 5, so it seems imposible to form a
 coorespondence such that they become countable.
 The trick here is to prepend a 1 to the binary strings so that the strings
 can become distinguishable.
 The aforementioned strings become 
\begin_inset Formula $1101,10101,100101$
\end_inset

 as integers they are 13, 21, and 37.
\end_layout

\begin_layout Subsection
Countability of Languages Over the Binary Alphabet
\end_layout

\begin_layout Standard
The next bit is quite confusing (pun intended).
 The languages over the binary alphabet 
\begin_inset Formula $\Sigma=\{0,1\}$
\end_inset

 are not countable.
 To obtain a contradiction we use a technique that confounds a set formers
 specification.
 As with the other examples suppose we could encode languages over the binary
 alphabet so that we could speak about some specific enumerated language.
 For example, the 
\begin_inset Formula $i^{th}$
\end_inset

 language.
 Define the language 
\begin_inset Formula $L$
\end_inset

 = { w | w is the 
\begin_inset Formula $i^{th}$
\end_inset

 binary string and 
\begin_inset Formula $w$
\end_inset

 is not in the 
\begin_inset Formula $i^{th}$
\end_inset

 language}.
 Surely, the language 
\begin_inset Formula $L$
\end_inset

 is a language over the binary alphabet.
 Thus, 
\begin_inset Formula $L$
\end_inset

 is the 
\begin_inset Formula $j^{th}$
\end_inset

 language for some particular 
\begin_inset Formula $j.$
\end_inset

 Now let some binary string 
\begin_inset Formula $x$
\end_inset

be the 
\begin_inset Formula $j^{th}$
\end_inset

 string.
 Now consider substituting 
\begin_inset Formula $x$
\end_inset

for 
\begin_inset Formula $w$
\end_inset

 in the 
\begin_inset Formula $j^{th}$
\end_inset

 language 
\begin_inset Formula $L_{j}$
\end_inset

 = { 
\begin_inset Formula $x$
\end_inset

 | 
\begin_inset Formula $x$
\end_inset

is the 
\begin_inset Formula $j^{th}$
\end_inset

 binary string and 
\begin_inset Formula $x$
\end_inset

is not in the 
\begin_inset Formula $j^{th}$
\end_inset

 language}.
 For some arbitrary 
\begin_inset Formula $j^{th}$
\end_inset

 string 
\begin_inset Formula $x$
\end_inset

in the 
\begin_inset Formula $j^{th}$
\end_inset

 language 
\begin_inset Formula $L_{j}$
\end_inset

, if 
\begin_inset Formula $x$
\end_inset

is in 
\begin_inset Formula $L_{j}$
\end_inset

, then it cannot be by the definition of the language.
 If 
\begin_inset Formula $x$
\end_inset

is not in the language 
\begin_inset Formula $L_{j}$
\end_inset

, then 
\begin_inset Formula $x$
\end_inset

is in the language by the definition of the language.
 This makes for a very confusing situation.
 Remember, 
\begin_inset Formula $L$
\end_inset

 contains 
\begin_inset Formula $w$
\end_inset

 if and only if 
\begin_inset Formula $w$
\end_inset

 is not the language that correpsonds to the smae integer 
\begin_inset Formula $i$
\end_inset

 that 
\begin_inset Formula $w$
\end_inset

 corresponds to.
 We now have a contradiction and therefore we know that we know the languages
 over the binary strings are not countable.
 Graphically, this concept can be seen in the Diagonalization Method in
 Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:diagonalization"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="8">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Strings
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Languages
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ddots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:diagonalization"

\end_inset

 This diagram depicts a table used to describe whether strings are in a
 language or not.
 A binary integer 1 indicates that the string 
\begin_inset Formula $j^{th}$
\end_inset

 string is in the 
\begin_inset Formula $i^{th}$
\end_inset

 language, 0 indicates it is not in the language.
 Look at the diagonal in this table.
 If you were to first complement the main diagonal and then rotate it by
 45 degrees upon an axis created in the 
\begin_inset Formula $i^{th}$
\end_inset

 row and 
\begin_inset Formula $i^{th}$
\end_inset

 column, then it too would look like a language, but would always disagree
 with itself at the 
\begin_inset Formula $i^{th}$
\end_inset

 row and 
\begin_inset Formula $i^{th}$
\end_inset

 column.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Turing Machines
\begin_inset CommandInset label
LatexCommand label
name "sec:Turing-Machines"

\end_inset


\end_layout

\begin_layout Standard
Turing machines model the recursively enumerable languages which encompass
 the previously discussed languages.
 Sipser provides a good hierarchy to reference for how to regard which language
 classes are subsets of which.
 The diagram is provided in Figure
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:languageClassHierarchy"

\end_inset

.
 The purpose of Turing Machine theory is to provide a means of proving whether
 or not an algorithm exists for a given language.Reductions which will be
 explored in detail in later sections prove common questions are undecidable.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/LanguageClassHierarchy.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:languageClassHierarchy"

\end_inset

 The hierarchy of language classes.
 Turing-recognizable languages are sometimes called recursively enumerable
 languages.
 Decidable languages are sometimes called recursive languages.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
What is a Turing Machine?
\end_layout

\begin_layout Standard
A Turing Machine is a computational model composed of a tape and a head
 that reads and writes symbols onto the tape based on a transition function.
 The tape is infinite in both directions, and there is also some state that
 we track throughout computation.
 In one step of computation the Turing machine may read one symbol from
 the tape and modify it, and either move the head left or right one square.
\end_layout

\begin_layout Subsection
Turing Machine Notation
\end_layout

\begin_layout Standard
A Turing machine is made up of the following componenets.
\end_layout

\begin_layout Itemize
A finite set of states (
\begin_inset Formula $Q).$
\end_inset


\end_layout

\begin_layout Itemize
An input alphabet 
\begin_inset Formula $(\Sigma).$
\end_inset


\end_layout

\begin_layout Itemize
A tape alphabet 
\begin_inset Formula $(\Gamma,$
\end_inset

typically 
\begin_inset Formula $\Sigma\subseteq\Gamma)$
\end_inset

.
\end_layout

\begin_layout Itemize
A transition function (
\begin_inset Formula $\delta$
\end_inset

).
\end_layout

\begin_layout Itemize
A start state (
\begin_inset Formula $q_{0}\varepsilon Q)$
\end_inset

.
\end_layout

\begin_layout Itemize
A blank symbol (
\begin_inset Formula $\sqcup\subseteq\Gamma-\Sigma).$
\end_inset


\end_layout

\begin_layout Itemize
A set of final states (
\begin_inset Formula $F\subseteq Q)$
\end_inset

.
\end_layout

\begin_layout Standard
Conventionally, the lowercase letters at the beginning of the alphabet are
 input symbols (
\begin_inset Formula $a,b,c).$
\end_inset

 Upper case letters at the end of the alphabet represetn tape symbols 
\begin_inset Formula $(X,Y,Z)$
\end_inset

.
 Lowercase letters at the end of the alphabet represent input strings 
\begin_inset Formula $w,x,y,z$
\end_inset

.
 Greek symbols represent tape symbols 
\begin_inset Formula $(\alpha,\beta,\gamma)$
\end_inset

.
 The transition function 
\begin_inset Formula $\delta$
\end_inset

 takes two parameters a 
\begin_inset Formula $q_{i}\varepsilon Q$
\end_inset

 and a tape symbol in 
\begin_inset Formula $\Gamma$
\end_inset

.
 The transition function yields a triple of the form (state, tape symbol,
 direction).
 If for a given input a tranisiton is not defined then the Turing machine
 halts in the current state.
\end_layout

\begin_layout Subsection
Instantaneous Descriptions of Turing Machines
\end_layout

\begin_layout Standard
Instantaneous descriptions of Turing Machines are encoded as 
\begin_inset Formula $\alpha q_{i}\beta$
\end_inset

 where 
\begin_inset Formula $\alpha$
\end_inset

 represents the tape before the head of the Turing Machine until the leftmost
 blank and 
\begin_inset Formula $\beta$
\end_inset

 represents the tape after the head until the rightmost blank.
 The position of the head represented by a state symbol 
\begin_inset Formula $q_{i}$
\end_inset

 is just left of the tape string 
\begin_inset Formula $\beta$
\end_inset

.
 Further we use the symbol 
\begin_inset Formula $\vdash$
\end_inset

 to indicate 
\begin_inset Quotes eld
\end_inset

becomes in one move
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Formula $\vdash^{*}$
\end_inset

 as 
\begin_inset Quotes eld
\end_inset

becomes in zero or more moves.
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Subsection
Languages of a Turing Machine
\end_layout

\begin_layout Standard
A Turing machine's language is defined by its final states or a halting
 action.
 An example is 
\begin_inset Formula $L(M)$
\end_inset

 = { 
\begin_inset Formula $w$
\end_inset

 | 
\begin_inset Formula $q_{0}w\vdash^{*}I$
\end_inset

 , where I is an ID with a final state}.
 Halting can be described by 
\begin_inset Formula $H(M)$
\end_inset

 = {
\begin_inset Formula $w$
\end_inset

 | 
\begin_inset Formula $q_{0}w\vdash^{*}I$
\end_inset

, and there is no move possible from 
\begin_inset Formula $I\}.$
\end_inset


\end_layout

\begin_layout Subsection
Recursively Enumerable Languages vs.
 Recursive Languages
\end_layout

\begin_layout Standard
The class of languages accepted by a Turing Machine halting or entering
 an accepting state is called the Recursively Enumerable language class.
 Some textbooks also call this the Turing Recognizable language class.
 Turing Machines that accept by final state, and who are 
\emph on
guaranteed to halt
\emph default
 whether it accepts or not define the Recursive Languages class.
 In some textbooks this is called the Decidable Language class.
 
\end_layout

\begin_layout Subsection
Multitape Turing Machines
\end_layout

\begin_layout Standard
Multitape Turing Machines allow for a ordinary Turing Machine to have 
\begin_inset Formula $k$
\end_inset

 tapes for any fixed 
\begin_inset Formula $k.$
\end_inset

 The steps the Multitape Turing Machine makes are dependant on the symbols
 the head of each tape is pointing to and their corresponding states.
 Each tape has its own head and they move on their own tape without restricting
 each others movement.
 On each read of the tape a new symbol and state is assigned for each tape
 and head.
 Additionally, a head may choose to not move.
 This model is no more powerful than the traditional Turing Machine.
 One may simply expand the alphabet for a traditional Turing Machine to
 accomadate the number of tapes that it must simulate.
\end_layout

\begin_layout Subsection
Nondeterministic Turing Machines
\end_layout

\begin_layout Standard
Nondeterministic Turing Machines are granted multiple choices based on the
 state, direction, move triple.
 Once a choice is made, then the next state, new symbol and head direction
 are determined.
 As with the NFA's, DFA's, and PDA's, the nondeterministic Turing Machine
 accpets if any sequence of choices leads to an ID with and accepting state.
\end_layout

\begin_layout Subsection
Closure Properties of Recursive and Recursively Enumerable Languages
\end_layout

\begin_layout Standard
Recursive Languages and Recursively Enumerable Languages share the properites:
 union, concatenation, Kleene star, reversal, intersection, and inverse.
 Recursive languages have difference and complementation.
 Recursively Enumerable Languages have homomorphism.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/ClosurePropertiesRELandRL.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:closurePropertiesOfRELandRELanguages"

\end_inset

The closure properties of Recursive and Recursively Enumerable languages
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Union
\end_layout

\begin_layout Standard
Given two Turing machines 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 with languages 
\begin_inset Formula $L_{1}$
\end_inset

and 
\begin_inset Formula $L_{2}$
\end_inset

 respectively.
 The union of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 can be achieved by creating a third Turing Machine 
\begin_inset Formula $M$
\end_inset

.
 
\begin_inset Formula $M$
\end_inset

will be a two-tape Turing Machine.
 
\begin_inset Formula $M$
\end_inset

 will proceed by copying the tape of 
\begin_inset Formula $M_{1}$
\end_inset

 to its first tape, and 
\begin_inset Formula $M_{2}$
\end_inset

 to its second tape.
 Next, 
\begin_inset Formula $M$
\end_inset

 will simulate the input of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 independently.
 In the case of Recursive Languages (Decidable Languages), 
\begin_inset Formula $M$
\end_inset

will 
\emph on
accept
\emph default
 when either of its tapes enter an accepting state, and 
\emph on
reject
\emph default
 when 
\series bold
both
\series default
 of its tapes halt by not accepting.
 The case for Recursively Enumerable Languages is a bit more relaxed.
 In this case, 
\begin_inset Formula $M$
\end_inset

 need only to enter an accepting state on one of its tapes to accept.
 However, it may end up running forever and never providing an answer.
 
\end_layout

\begin_layout Subsubsection
Intersection
\end_layout

\begin_layout Standard
The idea behind intersection is quite similiar to union.
 Given two Turing machines 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 with languages 
\begin_inset Formula $L_{1}$
\end_inset

and 
\begin_inset Formula $L_{2}$
\end_inset

 respectively.
 The intersection of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 can be achieved by creating a third Turing Machine 
\begin_inset Formula $M$
\end_inset

.
 
\begin_inset Formula $M$
\end_inset

will be a two-tape Turing Machine.
 
\begin_inset Formula $M$
\end_inset

will proceed by copying the tape of 
\begin_inset Formula $M_{1}$
\end_inset

 to its first tape, and 
\begin_inset Formula $M_{2}$
\end_inset

 to its second tape.
 Next, 
\begin_inset Formula $M$
\end_inset

 will simulate the input of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 independently.
 In the case of Recursive Languages (Decidable Languages), 
\begin_inset Formula $M$
\end_inset

will 
\emph on
accept
\emph default
 when 
\series bold
both
\series default
 of its tapes enter an accepting state, and 
\emph on
reject
\emph default
 when 
\series bold
either
\series default
 of its tapes halt by not accepting.
 In the Recursively Enumerable case, 
\begin_inset Formula $M$
\end_inset

 has to enter an accepting state on 
\series bold
both
\series default
 of its tapes to accept.
 However, it may end up running forever and never provide an answer.
 
\end_layout

\begin_layout Subsubsection
Difference and Complement
\end_layout

\begin_layout Standard
Again the idea behind Difference and Complement is quite similiar to the
 intersection.
 The intersection of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 can be achieved by creating a third Turing Machine 
\begin_inset Formula $M$
\end_inset

.
 
\begin_inset Formula $M$
\end_inset

 will be a two-tape Turing Machine.
 
\begin_inset Formula $M$
\end_inset

 will proceed by copying the tape of 
\begin_inset Formula $M_{1}$
\end_inset

 to its first tape, and 
\begin_inset Formula $M_{2}$
\end_inset

 to its second tape.
 Next, 
\begin_inset Formula $M$
\end_inset

 will simulate the input of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 independently.
 
\begin_inset Formula $M$
\end_inset

 will 
\emph on
accept
\emph default
 when 
\series bold

\begin_inset Formula $M_{1}$
\end_inset

 
\series default
accepts and 
\begin_inset Formula $M_{2}$
\end_inset

 rejects, otherwise reject.
 Corollary, for the complement run the difference algorithm over the Kleene
 star of the input alphabet.
 This approach won't work for Recursively Enumerable Languages because 
\begin_inset Formula $M_{2}$
\end_inset

 may never halt.
\end_layout

\begin_layout Subsubsection
Concatenation
\end_layout

\begin_layout Standard
Concatenation will require the use of a two-tape nondeterministic Turing
 Machine 
\begin_inset Formula $M$
\end_inset

.
 Assume that the given machines 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 are semi-inifinite single-tape Turing Machines.
 
\begin_inset Formula $M$
\end_inset

 will proceed by nondetminitically guessing the where a given input string
 
\begin_inset Formula $w$
\end_inset

 should be split.
 Call the prefix substring of 
\begin_inset Formula $w$
\end_inset

 the string 
\begin_inset Formula $x$
\end_inset

, and call the corresponding suffix 
\begin_inset Formula $y$
\end_inset

.
 Now copy 
\begin_inset Formula $x$
\end_inset

 onto 
\begin_inset Formula $M's$
\end_inset

 first tape and 
\begin_inset Formula $y$
\end_inset

onto its second tape.
 Now simulate 
\begin_inset Formula $M_{1}'s$
\end_inset

 transition function on the first tape and 
\begin_inset Formula $M_{2}'s$
\end_inset

 transtion function on the second tape.
 If both accept then 
\begin_inset Formula $M$
\end_inset

 should 
\emph on
accept
\emph default
, otherwise 
\emph on
reject
\emph default
.
 Because we nondeterministically guess all ways that 
\begin_inset Formula $w$
\end_inset

 can be split the machine will always accept if 
\begin_inset Formula $w$
\end_inset

 is in 
\begin_inset Formula $L(L(M_{1})L(M_{2})).$
\end_inset

 
\end_layout

\begin_layout Subsubsection
Kleene Star
\end_layout

\begin_layout Standard
For the Kleene star mirror the technique of used concatenation but instead
 of splitting the input string.
 Generate the Kleene star of the given Turing Machine and for each component
 of the guessed set run it against the Turing Machine and if it accepts
 then accept, otherwise reject.
\end_layout

\begin_layout Subsubsection
Reversal
\end_layout

\begin_layout Standard
Simply reverse the input and run it against the machine.
\end_layout

\begin_layout Section
Decidability
\begin_inset CommandInset label
LatexCommand label
name "sec:Undeciability"

\end_inset


\end_layout

\begin_layout Standard
Now that we have seen some algorithms in the preceeding section it is easy
 to see that one may create a great number of algorithms for Turing Machines.
 However, we will soon find out that for some problems no algorithm exists.
 We will link the concepts we learned in the Section
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Countability"

\end_inset

 to formulate a way of encoding Turing Machines in binary.
 This will allow us to apply the Diagonalization technique to Turing Machines.
 We can then formalize the notion that a problem posed to a Turing Machine
 is in fact the language of the Turing Machine.
 We can then see that for some languages no Turing Machine can exist.
\end_layout

\begin_layout Subsection
Encoding Turing Machines in Binary
\end_layout

\begin_layout Standard
It is quite simple to come up with a scheme for encoding Turing Machines
 into binary strings.
 We will assume the Turing Machines we will be encoding have a input alphate
 consisting of 
\begin_inset Formula $\{0,1\}.$
\end_inset

 However, this methodology is certainly exapandable to arbitrary alphabets.
 We should first assign integer values to the three classes of elements
 of the Turing Machine: states, symbols, and directions.
 Now we apply a trick for distinguishing codes of the binary string.
 For each integer representation of the componenet.
 Convert the integer to binary and insert a zero for each binary digit.
 Now there can never be consecutive ones in the binary representation.
 To distinguish between parts of the encoding add consecutive ones.
 Now we can concatenate the elements of the Turing machine together and
 prepend a 1 so that the encoding represents a unique integer value, and
 thus the language of all possible Turing Machines becomes enumerable.
 Some encodings may give invalid Turing Machines and therefore we regard
 theses as Turing Machines that accpet only the empty language.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="10">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String j
\begin_inset Formula $\rightarrow$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TM i
\begin_inset Formula $\rightarrow$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{1,1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{2,2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{3,3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{4,4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{5,5}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{6,6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ddots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:TuringMachineAcceptanceTable"

\end_inset

This table expreses which strings 
\begin_inset Formula $j$
\end_inset

 are accepted by which Turing Machines 
\begin_inset Formula $i$
\end_inset

.
 If 
\begin_inset Formula $x$
\end_inset

is 0 then the string is not accpeted, otherwise if 1 then it is accepted.
 The main diagonal 
\begin_inset Formula $D$
\end_inset

 is enumerated as 
\begin_inset Formula $a_{1,1},a_{2,2},a_{3,3},\ldots,a_{n,n}$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Diagonalization on the Enumerated Turing Machines
\begin_inset CommandInset label
LatexCommand label
name "subsec:DiagonalizationOnTuringMachines"

\end_inset


\end_layout

\begin_layout Standard
In order to diagonalize the table given by Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:TuringMachineAcceptanceTable"

\end_inset

.
 We form a sequence 
\begin_inset Formula $D$
\end_inset

 by complementing the values along the main diagonal.
 Formally 
\begin_inset Formula $D=$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $a_{i,j},\ldots,a_{n,n}$
\end_inset

 where 
\begin_inset Formula $i=j$
\end_inset

, and the value of 
\begin_inset Formula $a_{i,j}$
\end_inset

 is the complement of its value in the table shown in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:TuringMachineAcceptanceTable"

\end_inset

.
 Now we come to the question: Could 
\begin_inset Formula $D$
\end_inset

 be a row representing the language accepted by a Turing Machine of the
 table? Suppose this imaginary row represented by the main diagonal 
\begin_inset Formula $D$
\end_inset

 where row 
\begin_inset Formula $k$
\end_inset

, but it can't be row 
\begin_inset Formula $k$
\end_inset

 because it disagrees at the 
\begin_inset Formula $k^{th}$
\end_inset

 entry.
 Therefore this cannot be the language of any Turing Machine, and further
 we can descibe this language as the set that contains the 
\begin_inset Formula $k^{th}$
\end_inset

 string if and only if the 
\begin_inset Formula $k^{th}$
\end_inset

 Turing Machine does not accept the 
\begin_inset Formula $k^{th}$
\end_inset

 string.
 We can name this language 
\begin_inset Formula $L_{D}$
\end_inset

 and since we know that we can not create a Turing Machine for this langauge,
 then we know that it is not recursively enumeable (Turing-recogizable),
 and thus no algorithm can be given to decide 
\begin_inset Formula $L_{D}.$
\end_inset


\end_layout

\begin_layout Subsection
Decidable Problems
\end_layout

\begin_layout Standard
A problem is decidable if there is an algorithm to asnwer it.
 Recall, an algorithm formally speaking is a Turing Machine that halts on
 all inputs, accepted or not.
 Put another way a deciable problem is a recursive language.
 We may visualize the relationship among the language classes and the language
 
\begin_inset Formula $L_{D}$
\end_inset

 which we identified in subsection
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:DiagonalizationOnTuringMachines"

\end_inset

 in the Figure
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/DecidablityLanguageClass.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:DeciableLanguagesDiagram"

\end_inset

 Here we see the hierarchy of the language classes and how they relate to
 
\begin_inset Formula $L_{D}$
\end_inset

.
 The Undeciable Languages also called the Recursively Enumerable Languages
 have a Turing Machive and are regarded to be Turing-recognizable.
 That is, they have a Turing Machine that will accept strings, but there
 is no guarantee that the machine will halt.
 Within this class is the Decidable Languages also called the Recursive
 Languages which have Turing Machines which are guranteed to distinguish
 string as either accepted or rejected and they also are guranteed to halt.
 At the otter most ring we have the language for which no Turing Machine
 exists and therefore they are unrecognizable.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Universal Turing Machine
\end_layout

\begin_layout Standard
A Universal Turing Machine (UTM) is a Turing Machine which accepts as input
 a Turing Machine 
\begin_inset Formula $M$
\end_inset

 and some string 
\begin_inset Formula $w$
\end_inset

.
 The UTM accepts 
\begin_inset Formula $M$
\end_inset

 if and only if 
\begin_inset Formula $M$
\end_inset

accepts 
\begin_inset Formula $w.$
\end_inset

 A UTM will have three tapes.
 Tape 1 holds the input 
\begin_inset Formula $M$
\end_inset

encoded as binary and 
\begin_inset Formula $w.$
\end_inset

 Tape 2 holds the tape of 
\begin_inset Formula $M$
\end_inset

, and Tape 3 holds the state of 
\begin_inset Formula $M.$
\end_inset

 The UTM proceeds by first checking the encoding of 
\begin_inset Formula $M.$
\end_inset

 If 
\begin_inset Formula $M$
\end_inset

 is invalid, then its language is the empty language, and the UTM halts
 immediately and rejects.
 The UTM will then examine the size of 
\begin_inset Formula $M's$
\end_inset

 symbols to determine the required word size.
 Next, the UTM will initialize Tape 2 to represent the tape of 
\begin_inset Formula $M$
\end_inset

with the input 
\begin_inset Formula $w$
\end_inset

, and initialize Tape 3 to hold the start state.
 Finally, the UTM can simulate 
\begin_inset Formula $M$
\end_inset

 by looking for a step in the transition function of 
\begin_inset Formula $M$
\end_inset

encoded on Tape 1 that matches the state encoded on Tape 3 with a tape symbol
 under the head of Tape 2.
 If a match is found change the symbol and move the head marker on Tape
 2 and change the State on Tape 3.
 If 
\begin_inset Formula $M$
\end_inset

accepts, then the UTM accepts.
\end_layout

\begin_layout Subsection
The UTM is Recursively Enumerable and Not Recursive (The Halting Problem)
\begin_inset CommandInset label
LatexCommand label
name "subsec:haltingProblem"

\end_inset


\end_layout

\begin_layout Standard
Assume for the purposes of contradiction that the language of the UTM, that
 is 
\begin_inset Formula $L(UTM)$
\end_inset

, is recursive (decidable).
 Meaning that for every input it halts and returns an accepting or rejecting
 answer.
 We 
\emph on
somehow magically discover
\emph default
 an algorithm that can decide whether given a Turing Machine
\begin_inset Formula $M$
\end_inset

 and an input string 
\begin_inset Formula $w$
\end_inset

 from the acceptance table featured in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:TuringMachineAcceptanceTable"

\end_inset

– call this algorithm 
\emph on
wizzBang.
 
\emph default
Remember 
\emph on
wizzBang 
\emph default
takes two paramters as arguments.
 First, we must have a valid Turing Machine 
\begin_inset Formula $M$
\end_inset

, and second we must have a string 
\begin_inset Formula $w.$
\end_inset

 We’re given an input 
\begin_inset Formula $M$
\end_inset

.
 Let’s suppose 
\begin_inset Formula $M$
\end_inset

 is for the i-th string 
\begin_inset Formula $w$
\end_inset

 of our table.
 The first thing to do is check whether or not 
\begin_inset Formula $M$
\end_inset

 is a valid encoding for a Turing machine.
 If the encoding is NOT valid, then the i-th Turing Machine defines the
 empty language.
 That means 
\begin_inset Formula $w$
\end_inset

, the i-th string, is not in the language of the i-th Turing machine.
 Therefore, 
\begin_inset Formula $w$
\end_inset

 IS in 
\begin_inset Formula $L_{D}$
\end_inset

.
 Remeber we complemented the major diagonal so that answers here must be
 inverted.
 Now suppose 
\begin_inset Formula $M$
\end_inset

 is a valid encoding for a Turing machine.
 Then run 
\emph on
wizzBang
\emph default
 on the input 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

.
 Here 
\begin_inset Formula $M$
\end_inset

 represents the i-th Turing Machine processing the input that is the i-th
 string.
 Eventually, this algorithm will halt and tell us whether or not the i-th
 machine accepts the i-th string.
 If the 
\emph on
wizzBang
\emph default
 accepts the i-th machine accepts the i-th string, then we say reject because
 that means 
\begin_inset Formula $w$
\end_inset

 is not in 
\begin_inset Formula $L_{D}$
\end_inset

.
 However, if 
\emph on
wizzBang
\emph default
 rejects, then we accept 
\begin_inset Formula $w$
\end_inset

, because 
\begin_inset Formula $w$
\end_inset

 IS in 
\begin_inset Formula $L_{D}$
\end_inset

.
 HERE IS THE MAIN POINT
\begin_inset Formula $\Rightarrow$
\end_inset

 We previously proved in subsection
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:DiagonalizationOnTuringMachines"

\end_inset

 that no Turing Machine can exist for 
\begin_inset Formula $L_{D}$
\end_inset

 and therefore we must conclude that 
\emph on
wizzBang cannot exist.
 
\emph default
This tells us that the UTM is Recursively Enumerable (Turing-recognizable),
 but not Recursive (Decidable).
 We will regard the language of the UTM as 
\begin_inset Formula $L_{U}$
\end_inset

 going forward.
\end_layout

\begin_layout Section
Some Undeciable Problems
\end_layout

\begin_layout Standard
In this section we cover Rice's Theorem which states that almost every question
 we ask about Recursively Enumerable Languages is undeciable.
 Next we look to Post's Correspondence Problem to bridge the gap between
 the world of Turing Machine to solving real world problems.
 In addition to the classical language classes we have defined we may define
 properties of languages.
 A property is a user defined set of languages.
 For example, the set of languages who are infinite languages have the Infiniten
ess Property.
 We can define a language 
\begin_inset Formula $L_{P}$
\end_inset

 as the set of TM's such that each TM has the property 
\begin_inset Formula $P$
\end_inset

.
 There are two trivial propertues 
\begin_inset Formula $P$
\end_inset

 for which 
\begin_inset Formula $L_{P}$
\end_inset

 is deciable.
 The always-false propety, which contains no Recursively Enumerable languages,
 and the always-true property, which contains every Recursively Enumerable
 language.
 Rice's Theorem states that for every other property 
\begin_inset Formula $P$
\end_inset

 besides the trivial ones 
\begin_inset Formula $L_{P}$
\end_inset

 is undecidable.
 In order to prove Rice's Theorem we will have to introduce the concept
 of reductions.
 A reduction is an algorithm (Recall, an algorithm is a TM that always halts),
 which transforms an input string 
\begin_inset Formula $w$
\end_inset

 in 
\begin_inset Formula $L$
\end_inset

 to a string 
\begin_inset Formula $x$
\end_inset

in 
\begin_inset Formula $L'$
\end_inset

 with the property that 
\begin_inset Formula $x$
\end_inset

is in 
\begin_inset Formula $L'$
\end_inset

 if and only if 
\begin_inset Formula $w$
\end_inset

 is in 
\begin_inset Formula $L.$
\end_inset

 The takeaway here is that given the reduction for 
\begin_inset Formula $L$
\end_inset

 we are able to say that 
\begin_inset Formula $L$
\end_inset

 is no harder than 
\begin_inset Formula $L'.$
\end_inset

 We can visualize reductions as shown in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Reductions"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/Reduction.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Reductions"

\end_inset

 The transducer serves as an adaptor for the input string of 
\begin_inset Formula $w$
\end_inset

.
 It transforms 
\begin_inset Formula $w$
\end_inset

 into a string 
\begin_inset Formula $x$
\end_inset

which 
\begin_inset Formula $L'$
\end_inset

 can consume and produce an accept or reject decision.
 Algorithm 
\begin_inset Formula $L'$
\end_inset

 allows us to draw conclusions about the properties of 
\begin_inset Formula $L.$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Rice's Theorem
\end_layout

\begin_layout Standard
We now need to prove the claim of Rice's Theorem: Every nontrivial property
 
\begin_inset Formula $P$
\end_inset

 of the Recursively Enumerable languages, 
\begin_inset Formula $L_{P}$
\end_inset

, is undecidable.
 We’re going to assume that the empty language does not have property P.
 If that is not the case, then consider the complement of P, say Q.
 Surely the empty language then has property Q.
 But if we could prove that Q were undecidable, then P also must be undecidable.
 That is, if L_P were a recursive language, then so would be L_Q, since
 the class of recursive languages is closed under complementation.
 We will use the UTM (i.e.
 
\begin_inset Formula $L_{U}$
\end_inset

) obtained in Section
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:haltingProblem"

\end_inset

.
 In this reduction we reduce 
\begin_inset Formula $L_{U}$
\end_inset

 to 
\begin_inset Formula $L_{P}$
\end_inset

.
 Because 
\begin_inset Formula $L_{U}$
\end_inset

 is undecidable this gives us the ability to say that 
\begin_inset Formula $L_{P}$
\end_inset

 is undecidable.
 Our reduction must take the parameters 
\begin_inset Formula $M$
\end_inset

and 
\begin_inset Formula $w$
\end_inset

 and create a new Turing Machine 
\begin_inset Formula $M'$
\end_inset

 such that 
\begin_inset Formula $L(M')$
\end_inset

 has property 
\begin_inset Formula $P$
\end_inset

 if and only if 
\begin_inset Formula $M$
\end_inset

 accepts 
\begin_inset Formula $w$
\end_inset

.
 That is, the result of 
\begin_inset Formula $M'$
\end_inset

 is contingent on the result of 
\begin_inset Formula $M$
\end_inset

's result from taking in 
\begin_inset Formula $w$
\end_inset

.
 Our language property testing machine 
\begin_inset Formula $M'$
\end_inset

 will be testing the language 
\begin_inset Formula $L$
\end_inset

 such that 
\begin_inset Formula $L$
\end_inset

 is any language with a property 
\begin_inset Formula $P$
\end_inset

, and we let 
\begin_inset Formula $M_{L}$
\end_inset

 be a TM that accepts 
\begin_inset Formula $L$
\end_inset

.
 
\begin_inset Formula $M'$
\end_inset

 simulates 
\begin_inset Formula $M$
\end_inset

 on input 
\begin_inset Formula $w$
\end_inset

, and if 
\begin_inset Formula $M$
\end_inset

 accepts 
\begin_inset Formula $w$
\end_inset

 then 
\begin_inset Formula $M'$
\end_inset

 simulates 
\begin_inset Formula $M_{L}$
\end_inset

 on the input 
\begin_inset Formula $x$
\end_inset

to 
\begin_inset Formula $M'$
\end_inset

.
 
\begin_inset Formula $M'$
\end_inset

 accepts its input 
\begin_inset Formula $x$
\end_inset

if and only if 
\begin_inset Formula $M_{L}$
\end_inset

 accepts 
\begin_inset Formula $x.$
\end_inset

 Suppose 
\begin_inset Formula $M$
\end_inset

 accepts 
\begin_inset Formula $w$
\end_inset

, then 
\begin_inset Formula $M'$
\end_inset

will simulate 
\begin_inset Formula $M_{L}$
\end_inset

 on input 
\begin_inset Formula $x$
\end_inset

and therefore accepts 
\begin_inset Formula $x$
\end_inset

if and only if 
\begin_inset Formula $x$
\end_inset

is in 
\begin_inset Formula $L.$
\end_inset

 Formally, 
\begin_inset Formula $L(M')=L(M_{L})=L$
\end_inset

, the language of 
\begin_inset Formula $M'$
\end_inset

 is the language of 
\begin_inset Formula $M_{L}$
\end_inset

, 
\begin_inset Formula $L(M')$
\end_inset

 has property 
\begin_inset Formula $P$
\end_inset

, and 
\begin_inset Formula $M'$
\end_inset

 is in 
\begin_inset Formula $L_{P}.$
\end_inset

 Now suppose the other case, 
\begin_inset Formula $M$
\end_inset

 does not accpet (never halts) 
\begin_inset Formula $w$
\end_inset

, then 
\begin_inset Formula $M'$
\end_inset

 never starts the simulation of 
\begin_inset Formula $M_{L}$
\end_inset

 and thus never accpets the input 
\begin_inset Formula $x$
\end_inset

, so 
\begin_inset Formula $L(M')=L(M_{L})=\emptyset$
\end_inset

.
 Therefore, 
\begin_inset Formula $L(M')$
\end_inset

 does not have the property 
\begin_inset Formula $P$
\end_inset

.
 
\begin_inset Formula $M'$
\end_inset

 is not in 
\begin_inset Formula $L_{P}$
\end_inset

.
 This can viewed graphically in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:schematicRiceTheoremTM"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/riceTheoremTuringMachine.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:schematicRiceTheoremTM"

\end_inset

 Here we see a schematic of the TM 
\begin_inset Formula $M'$
\end_inset

 in which the language of 
\begin_inset Formula $M_{L}$
\end_inset

 is the language 
\begin_inset Formula $L_{P}$
\end_inset

 who can only run once if 
\begin_inset Formula $w$
\end_inset

 is accepted by M whose language is 
\begin_inset Formula $L_{U}$
\end_inset

.
 As a whole this can be regarded as a reduction from 
\begin_inset Formula $L_{U}$
\end_inset

 to 
\begin_inset Formula $L_{P}$
\end_inset

.
 Since we know 
\begin_inset Formula $L_{U}$
\end_inset

 is undeciable then so is 
\begin_inset Formula $L_{P}$
\end_inset

.
 In essence it is bootstrapped by 
\begin_inset Formula $L_{U}$
\end_inset

 undecidability.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Post's Correspondence Problem
\end_layout

\begin_layout Standard
Post's Correspondence Problem (PCP) will be a tool for us to use in developing
 proving other problems are undecidable so its worth the effort of understanding.
 PCP asks: Is there some some ordering of indicies 
\begin_inset Formula $i_{1}\ldots i_{k}$
\end_inset

 for a list of cooresponding strings 
\begin_inset Formula $(w_{1},x_{1}),(w_{2},x_{2}),\ldots,(w_{n},x_{n})$
\end_inset

 such that 
\begin_inset Formula $w_{i}\ldots w_{n}=x_{i}\ldots x_{n}.$
\end_inset

 A restriction we place on this question is that neither strings of 
\begin_inset Formula $w_{i}$
\end_inset

 nor 
\begin_inset Formula $x_{i}$
\end_inset

 can be the empty string, and they share the same alphabet.
 In less formal terms, PCP asks is there a way of concatenating 
\begin_inset Formula $w$
\end_inset

-type strings with 
\begin_inset Formula $x$
\end_inset

-type strings so that they beome equivalent strings.
 
\end_layout

\begin_layout Subsection
PCP is Undecidable
\end_layout

\begin_layout Standard
The proof that PCP is undeciable relies on two reductions.
 The first reduction is from 
\begin_inset Formula $L_{U}$
\end_inset

, the language of the Univeral Turing Machine, to 
\begin_inset Formula $MPCP$
\end_inset

.
 
\begin_inset Formula $MPCP$
\end_inset

 can be regarded as a modified version of the PCP problem such that the
 first pair must be chosen first when forming the match on 
\begin_inset Formula $w$
\end_inset

 and 
\begin_inset Formula $x.$
\end_inset

 Then next reduction is from 
\begin_inset Formula $MPCP$
\end_inset

 to 
\begin_inset Formula $PCP$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Reduction from 
\begin_inset Formula $L_{U}$
\end_inset

 to MPCP
\end_layout

\begin_layout Standard
//TODO
\end_layout

\begin_layout Subsubsection
Reduction from MPCP to PCP
\end_layout

\begin_layout Standard
//TODO
\end_layout

\begin_layout Subsection
Some Real Problems
\end_layout

\begin_layout Standard
//TODO
\end_layout

\begin_layout Part
Complexity
\end_layout

\begin_layout Section
Time Complexity (Bachmann-Landau Notation)
\begin_inset CommandInset label
LatexCommand label
name "sec:Big-O-Analysis"

\end_inset


\end_layout

\begin_layout Section
Space Complexity
\end_layout

\begin_layout Section
Intractable Problems
\end_layout

\begin_layout Standard
In this section we learn about Time-Bounded Turing Machines, The Polynomial
 Class of Problems, P, and the Exponenetial Class of Problems, NP.
 Lastly we learn about Polynomial-Time Reductions.
 Refer to Michael Garey and David Johnson's 
\emph on
Computers and Intractability: A Guide to the Theory of NP-Completeness 
\emph default
as a primary source for this subject matter.
\end_layout

\begin_layout Subsection
Time Bounded Turing Machines
\end_layout

\begin_layout Standard
We say a Turing machine is 
\begin_inset Formula $T(n)$
\end_inset

 time bounded, where
\begin_inset Formula $T(n)$
\end_inset

 is some function of 
\begin_inset Formula $n$
\end_inset

, like 
\begin_inset Formula $n^{2}$
\end_inset

 or 
\begin_inset Formula $2^{n}$
\end_inset

, if given an input of length 
\begin_inset Formula $n$
\end_inset

, the machine always halts in at most 
\begin_inset Formula $T(n)$
\end_inset

 steps.
 
\end_layout

\begin_layout Subsection
The Partial Order of Equivalance Classes P, NP, and NP-complete
\end_layout

\begin_layout Standard
A Turing machine 
\begin_inset Formula $M$
\end_inset

 is said to be polynomial-time bounded if it is time bounded by any polynomial.
 It could be linear, or quadratic, or cubic, or 
\begin_inset Formula $n^{1000}$
\end_inset

, as long as it is some polynomial.
 The languages who are said to be bounded by polynomial time make up the
 Polynomial class P.
 For more complex polynomials you may wonder if they qualify for the class
 P.
 A problem qualifies to be in P if it is less than some polynomial.
 For example, 
\begin_inset Formula $O(nlogn)$
\end_inset

 is less than 
\begin_inset Formula $O(n^{2})$
\end_inset

, and therefore it qualifies for the class P.
 The nondeterminitic polynomial NP class of problems is defined in term
 of a NTM which has a polynomial time nondeterministic algorithm.
 The algorithm should be composed of two seperate states.
 Th first is the guessing stage, and the second is the checking stage.
 A nondeterministic algorithm 
\begin_inset Quotes eld
\end_inset

solves
\begin_inset Quotes erd
\end_inset

 a descisions problem 
\begin_inset Formula $\Pi$
\end_inset

 if the followung two properties hold for all instances.
\end_layout

\begin_layout Enumerate
If the instance of the problem is an accepting instance, then there exists
 
\emph on
some
\emph default
 structure 
\begin_inset Formula $S$
\end_inset

 that, when guessed for the input of the instance, will lead to the checking
 stage to 
\emph on
accept
\emph default
 for the instance and 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Enumerate
If the instance of the problem is an rejecting instance, then there exists
 
\emph on
no
\emph default
 structure 
\begin_inset Formula $S$
\end_inset

 that, when guessed for the input of the instance, will lead to the checking
 stage to 
\emph on
reject
\emph default
 for the instance and 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Standard
If there is a polynomial bound on the number steps an NTM must take in any
 branch of its computation then the problem is in NP.
 The term 
\begin_inset Quotes eld
\end_inset

complete problem
\begin_inset Quotes erd
\end_inset

 for class of problems means that the problem embodies the essence of all
 other problems in the class.
 Even though it may appear that the problem doesn't.
 PCP embodies Turing Machine computation.
 and the Knapsack Problem embodies all NTM computation.
 Polynomial Time reductions allow us to define NP-Complete problems.
 In order to show a problem 
\begin_inset Formula $M$
\end_inset

 to be NP-complete, we have to show that every problem in NP is somehow
 embedded in 
\begin_inset Formula $L$
\end_inset

.
 We need a transformation from every problem in NP to 
\begin_inset Formula $M$
\end_inset

, and this transformation has to be sufficiently fast that if we had a determini
stic polynomial time algorithm for 
\begin_inset Formula $M$
\end_inset

, then we could use it to build a deterministic polynomial time algorithm
 for each problem in NP.
 Formally, we say a problem or language 
\begin_inset Formula $M$
\end_inset

 is NP-complete if, first of all, it is in NP, and for every language 
\begin_inset Formula $L$
\end_inset

 in NP, there is a polytime reduction from 
\begin_inset Formula $L$
\end_inset

 to 
\begin_inset Formula $M$
\end_inset

.
\end_layout

\begin_layout Standard
A final point on producing creating nondeterministic algorithms for NP problems
 concerns the status of the algorithms complement.
 There is a lack of symmetry the accepting and rejecting instances.
 
\emph on
In a deterministic algorithm
\emph default
, for a problem 
\begin_inset Quotes eld
\end_inset

Given an instance of the problem 
\begin_inset Formula $I$
\end_inset

, is 
\begin_inset Formula $X$
\end_inset

 true for 
\begin_inset Formula $I$
\end_inset


\begin_inset Quotes erd
\end_inset

, where 
\begin_inset Formula $X$
\end_inset

 is some property, both the problem and its complement can be solved polynomiall
y because a deterministic algorithm always halts.
 To obtain the complent you would just interchange the accepting and rejecting
 results.
 
\emph on
In a nondeterministic algorithm
\emph default
,
\emph on
 
\emph default
for example the complement of the TSP problem–this is not the case.
 Consider the complement of TSP: 
\begin_inset Quotes eld
\end_inset

Given a set of cities, intercity distances, and a bound 
\begin_inset Formula $B,$
\end_inset

 is it true that 
\emph on
no
\emph default
 tour of all the citeis has length 
\begin_inset Formula $B$
\end_inset

or less? There is no know way to verify a 
\begin_inset Quotes eld
\end_inset

yes
\begin_inset Quotes erd
\end_inset

 answer to this problem other than computing all possible tours (an exponential
 algorithm).
 Thus membership P for a given problem implies membership in coP.
 However membership in NP does not imply membership in coNP.
 The prefix 
\begin_inset Quotes eld
\end_inset

co
\begin_inset Quotes erd
\end_inset

 implies the complement of this language class.
 A tentative view of the world of NP can be seen in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:npHiearchy"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/npHierarchy.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:npHiearchy"

\end_inset

 This diagram gives a tentative view of the membership relationship among
 the different language classes.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Encoding Schemes
\end_layout

\begin_layout Standard
It is important to note the effect an encoding scheme can have on an algorithm.
 If the encoding scheme is poorly constructed the input length might become
 exponential and thus violate one of the rules of prooving NP-completeness.
 An example of reasonable encoding schemes can be seen in in Figure
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:graphEncodingSchemes"

\end_inset

.
 Similary, if the output of our polynomial reduction becomes is not described
 in a polynomial length of the input then it too violates the rules of prooving
 NP-completeness.
 An example of this is a variant of the Traveling Salesman Problem (TSP)
 problem.
 This variant gives a bounds 
\begin_inset Formula $B$
\end_inset

 and asks for all tours of length 
\begin_inset Formula $B$
\end_inset

 or less yielding exponentially many tours less than 
\series bold

\begin_inset Formula $B$
\end_inset

.

\series default
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encoding Schemes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vertex list, Edge list
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V[1]V[2]V[3]V[4](V[1]V[2])(V[2]V[3])
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adjacency list
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(V[2])(V[1]V[3])(V[2])()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Adjacency matrix
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0100/1010/0010/0000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lower Bound
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Upper Bound
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4v+10e$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4v+10e+(v+2e)\cdot\left\lceil \log_{10}v\right\rceil $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2v+8e$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2v+8e+2e\cdot\left\lceil \log_{10}v\right\rceil $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v^{2}+v-1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $v^{2}+v-1$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:graphEncodingSchemes"

\end_inset

 The table above demonstrates how a graph's description can be described.
 The string length is given by length column.
 For sparse graphs an adjaceny list representation is beneficial.
 Dense graphs should be represented in an adjacency matrix.
 The bounds describe the input length in terms of 
\begin_inset Formula $v$
\end_inset

 and 
\begin_inset Formula $e$
\end_inset

, for 
\begin_inset Formula $G(V,E)$
\end_inset

 where 
\begin_inset Formula $v=|V|$
\end_inset

 and 
\begin_inset Formula $e=|E|$
\end_inset

.
 Graphs encoded in any of these schemes will differ at most polynomially
 for any instance of a graph.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Transitivity of NP-completeness
\end_layout

\begin_layout Standard
Polynomial transformations provide membership for languages to equivalence
 classes with the following Lemma.
 Visually this can be seen in the diagram for Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:schematicRiceTheoremTM"

\end_inset

.
\end_layout

\begin_layout Lemma
If 
\begin_inset Formula $L_{1}\propto L_{2}$
\end_inset

 and 
\begin_inset Formula $L_{1}$
\end_inset

 
\begin_inset Formula $\epsilon$
\end_inset


\emph on
P, 
\emph default
then 
\begin_inset Formula $L_{2}$
\end_inset

 
\begin_inset Formula $\epsilon$
\end_inset


\emph on
P.
 
\emph default
Equivalently, If 
\begin_inset Formula $L_{1}\propto L_{2}$
\end_inset

 and 
\begin_inset Formula $L_{1}$
\end_inset

 
\begin_inset Formula $\not\epsilon$
\end_inset


\emph on
 P, 
\emph default
then 
\begin_inset Formula $L_{2}$
\end_inset

 
\begin_inset Formula $\not\epsilon$
\end_inset


\emph on
 P.
\begin_inset CommandInset label
LatexCommand label
name "lem:pMembership"

\end_inset


\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $\Sigma_{1}$
\end_inset

and 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 be the alphabets of languages 
\begin_inset Formula $L_{1}$
\end_inset

 and 
\begin_inset Formula $L_{2}$
\end_inset

 respectively, and let the function 
\begin_inset Formula $f:\Sigma_{1}^{*}\rightarrow\Sigma_{2}^{*}$
\end_inset

 be a 
\emph on
polytime
\emph default
 function from 
\begin_inset Formula $L_{1}$
\end_inset

 to 
\begin_inset Formula $L_{2}$
\end_inset

.
 Let 
\begin_inset Formula $M_{f}$
\end_inset

 be a determinitic 
\emph on
polytime
\emph default
 DTM recoginizer computing the function 
\begin_inset Formula $f$
\end_inset

.
 Let 
\begin_inset Formula $M_{2}$
\end_inset

 be a 
\emph on
polytime 
\emph default
DTM recognzier for 
\begin_inset Formula $L_{2}.$
\end_inset

 A 
\emph on
polytime
\emph default
 recognizer for 
\begin_inset Formula $L_{1}$
\end_inset

 can be constructed by composing 
\begin_inset Formula $M_{f}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

.
 For an input 
\begin_inset Formula $x$
\end_inset


\begin_inset Formula $\epsilon$
\end_inset

 
\begin_inset Formula $L_{1}$
\end_inset

 we first apply the part of the program attributed to 
\begin_inset Formula $M_{f}$
\end_inset

 which yields 
\begin_inset Formula $f(x)$
\end_inset

 
\begin_inset Formula $\epsilon$
\end_inset

 
\begin_inset Formula $\Sigma_{2}$
\end_inset

 ( a string of the 
\begin_inset Formula $L_{2}$
\end_inset

's alphabet).
 We the apply the recognizer 
\begin_inset Formula $M_{2}$
\end_inset

 to the program to determine if the string 
\begin_inset Formula $f(x)$
\end_inset

 
\begin_inset Formula $\epsilon$
\end_inset


\begin_inset Formula $L_{2}.$
\end_inset

 Since 
\begin_inset Formula $x$
\end_inset


\begin_inset Formula $\epsilon$
\end_inset


\begin_inset Formula $L_{1}$
\end_inset

 if and only if 
\begin_inset Formula $f(x)$
\end_inset

 
\begin_inset Formula $\epsilon$
\end_inset


\begin_inset Formula $L_{2}$
\end_inset

 we now have a recognizer for 
\begin_inset Formula $L_{1}.$
\end_inset

 The fact that this yields a polynomial algorithm is derived from the fact
 that both 
\begin_inset Formula $M_{f}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 are polytime algorithms themselves.
 
\end_layout

\begin_layout Standard
Reductions have the feature of transitivity.
 
\end_layout

\begin_layout Lemma
That is, if 
\begin_inset Formula $L_{1}\propto L_{2}$
\end_inset

 and 
\begin_inset Formula $L_{2}\propto L_{3}$
\end_inset

, then 
\begin_inset Formula $L_{1}\propto L_{3}$
\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "lem:reductionTransitiviy"

\end_inset


\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $\Sigma_{1},\Sigma_{2},\Sigma_{3}$
\end_inset

 be the alphabets for 
\begin_inset Formula $L_{1},L_{2}$
\end_inset

 and 
\begin_inset Formula $L_{3}$
\end_inset

 respectively.
 The function mapping the language of 
\begin_inset Formula $L_{1}$
\end_inset

 to the language of 
\begin_inset Formula $L_{2}$
\end_inset

 is given by 
\begin_inset Formula $f_{1}:\Sigma_{1}^{*}\rightarrow\Sigma_{2}^{*}$
\end_inset

, and the function mapping the language of 
\begin_inset Formula $L_{2}$
\end_inset

 to the language of 
\begin_inset Formula $L_{3}$
\end_inset

 is 
\begin_inset Formula $f_{2}:\Sigma_{2}^{*}\rightarrow\Sigma_{3}^{*}$
\end_inset

.
 Then the function transforming the language of 
\begin_inset Formula $L_{1}$
\end_inset

 to the language of 
\begin_inset Formula $L_{3}$
\end_inset

 is the composition of the given functions, 
\begin_inset Formula $f(x)=f_{2}(f_{1}(x))$
\end_inset

, for all strings 
\begin_inset Formula $x$
\end_inset

in 
\begin_inset Formula $L_{1}$
\end_inset

.
 Clearly, 
\begin_inset Formula $f(x)\epsilon L_{3}$
\end_inset

 if and only if 
\begin_inset Formula $x\epsilon L_{1}$
\end_inset

.
 The fact that 
\begin_inset Formula $f$
\end_inset

 can be computed polynomially is derived from Lemma
\begin_inset CommandInset ref
LatexCommand vref
reference "lem:pMembership"

\end_inset

.
\end_layout

\begin_layout Standard
An import lemma that allows us to constuct the NP-complete equivalence class
 is the application of reduction transitivity to NP-complete problems.
\end_layout

\begin_layout Lemma
If 
\begin_inset Formula $L_{1}$
\end_inset

 and 
\begin_inset Formula $L_{2}$
\end_inset

 belong to NP, 
\begin_inset Formula $L_{1}$
\end_inset

 is NP-complete, and 
\begin_inset Formula $L_{1}\propto L_{2}$
\end_inset

, then 
\begin_inset Formula $L_{2}$
\end_inset

 is NP-complete.
\end_layout

\begin_layout Proof
Since 
\begin_inset Formula $L_{2}$
\end_inset

 
\begin_inset Formula $\epsilon$
\end_inset


\emph on
NP
\emph default
 all we need to do is show that, for every 
\begin_inset Formula $L'$
\end_inset


\emph on
 
\begin_inset Formula $\epsilon$
\end_inset

 NP
\emph default
, 
\begin_inset Formula $L'\propto L_{2}$
\end_inset

.
 Consider any 
\begin_inset Formula $L'$
\end_inset

 
\begin_inset Formula $\epsilon$
\end_inset

 
\emph on
NP
\emph default
.
 Since 
\begin_inset Formula $L_{1}$
\end_inset

 is NP-complete, then surely 
\begin_inset Formula $L'\propto L_{1}$
\end_inset

 by the definition of NP-completeness.
 The tranistivity of 
\begin_inset Formula $\propto$
\end_inset

 seen in Lemma
\begin_inset CommandInset ref
LatexCommand vref
reference "lem:reductionTransitiviy"

\end_inset

, and the fact that 
\begin_inset Formula $L_{1}\propto L_{2}$
\end_inset

 implies that 
\begin_inset Formula $L'\propto L_{2}$
\end_inset

 .
 
\end_layout

\begin_layout Proof
So it clear that once we have a single NP-complete problem to stand in for
 
\begin_inset Formula $L_{1}$
\end_inset

 it serves as a means to bootstrap the process of creating the NP-complete
 equivalence class.
 The first NP-complete problem that allows the process was provided by Steve
 Cook and is discussed in Section
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:Cook's-Theorem"

\end_inset

.
\end_layout

\begin_layout Subsection
Prooving NP-completeness
\end_layout

\begin_layout Standard
In order to prove that a problem is NP-complete you will need to demonstrate
 the following:
\end_layout

\begin_layout Enumerate
Show that the problem is in NP by giving a nondeterministic polytime decider.
\end_layout

\begin_layout Enumerate
Select an known NP-complete problem.
\end_layout

\begin_layout Enumerate
Construct a transformation function 
\begin_inset Formula $f$
\end_inset

 from the NP-completer problem to the problem in question.
\end_layout

\begin_layout Enumerate
Prove that the tranformation function 
\begin_inset Formula $f$
\end_inset

 is a polynomial tranformaton.
\end_layout

\begin_layout Standard
Garey and Johnson suggest that three design patterns exist for proving NP-comple
teness: restriction, local replacement and component design.
 Descriptions of the three patters are given.
\end_layout

\begin_layout Subsubsection
Restriction
\end_layout

\begin_layout Subsubsection
Local Replacement
\end_layout

\begin_layout Subsubsection
Component Design
\end_layout

\begin_layout Subsection
Polynomial Time Reductions
\end_layout

\begin_layout Standard
Polynomial time transducers are TM's that take in an input of length n,
 operate deterministically for some polynomial time 
\begin_inset Formula $p(n)$
\end_inset

.
 Produces an output on a separate output tape, and the output must me at
 most 
\begin_inset Formula $p(n)$
\end_inset

.
 Consider two languages or problems, say 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

.
 We say 
\begin_inset Formula $L$
\end_inset

 is polytime-reducible to 
\begin_inset Formula $M$
\end_inset

 if there is a polytime transducer 
\begin_inset Formula $T$
\end_inset

 that takes an input 
\begin_inset Formula $w$
\end_inset

 that is an instance of 
\begin_inset Formula $L$
\end_inset

, produces output 
\begin_inset Formula $x$
\end_inset

 that is an instance of 
\begin_inset Formula $M$
\end_inset

, and the answer to 
\begin_inset Formula $L$
\end_inset

 on 
\begin_inset Formula $w$
\end_inset

 is the same as the answer to 
\begin_inset Formula $M$
\end_inset

 on 
\begin_inset Formula $x$
\end_inset

.
 That is, 
\begin_inset Formula $w$
\end_inset

 is in 
\begin_inset Formula $L$
\end_inset

 if and only if 
\begin_inset Formula $x$
\end_inset

 is in 
\begin_inset Formula $M$
\end_inset

.
 
\end_layout

\begin_layout Standard
Steve Cook and Dick Karp were the pioneers of NP-Completeness theory.
 Cook concentrated on 3-SAT – the question of whether an expression of proposeit
ional logic was satisfiable, that is, made true by some assignment of truth
 values to the propositional variables.
 But shortly after Cook wrote his original paper on NP-completeness, Dick
 Karp wrote another paper that showed many of the classical problems that
 had been puzzling mathematicians, sometimes for centuries, were NP-complete.
 Karp used only polytime reductions to the problem Cook had proved NP-complete.
 Since then, it is generally accepted that the preferred definition of NP-comple
teness is the one we gave here – the existence of polytime reductions.
 To make the distinction, this notion of NP-completeness is often called
 Karp-completeness.
 
\end_layout

\begin_layout Subsection
Cook's Theorem
\begin_inset CommandInset label
LatexCommand label
name "subsec:Cook's-Theorem"

\end_inset


\end_layout

\begin_layout Standard
Recall from the Section
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:propositionalSententialLogic"

\end_inset

 on propositional logic that we expresses the truth of expressions with
 boolean operators.
 Expressions are built from two components variables and constants using
 boolean the operators (
\begin_inset Formula $\land,\lor,\lnot).$
\end_inset

 Constants and the value of variables are either true (1) or false (0).
 The order of precedence for the boolean operatios is NOT, AND, OR.
 The Satisfiability Problem (SAT) is concened with determinig if there is
 a satisfying assignment of boolean values to an expression such that the
 expression is true.
 Instances of the SAT problem are represented with the parenthesis, logical
 operators, and variables 
\begin_inset Formula $x_{i}$
\end_inset

 where 
\begin_inset Formula $i$
\end_inset

 is the 
\begin_inset Formula $i^{th}$
\end_inset

 binary integer.
 
\end_layout

\begin_layout Standard
In order to prove that SAT is NP-Complete we must first show that it is
 in NP.
 This can be done by giving an NTM that decides if an instance of SAT of
 length 
\begin_inset Formula $n$
\end_inset

is satisfiable.
 The algorithm for this Turing Machine can use nondeterminisc guessing to
 accomplish the goal.
 First the NTM guesses truth values for the variables of the expression.
 The NTM then checks the truth values of the expression.
 If the expression is true, then accept, otherwise reject.
 We now know that SAT is in NP.
\end_layout

\begin_layout Standard
The next step is to prove that SAT is NP-complete.
 Refer to Garey and Johnson pg 39-44 for the indepth proof.
 Prior to reading this you should understand Logic Programming 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Logic_programming
\end_layout

\end_inset

 and Lambda Calculus 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Lambda_calculus
\end_layout

\end_inset

.
 At a high level the transformation function that they provide is based
 on the idea that the intermediate descriptions of the Turing machine can
 be translated into logical programming constraints which represent the
 clauses of the satisfiability problem.
 
\end_layout

\begin_layout Section
Specific NP-Complete Problems
\end_layout

\begin_layout Standard
Garey and Johnson provide six additional foundational NP-complete problems
 which they have found to be the most useful.
 The relationship between these problems can be seen in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:npCompleteTree"

\end_inset

.
 
\end_layout

\begin_layout Enumerate
3SAT asks the question: Is there a truth assignment for a set of clauses
 in which all clauses have 3 variables? 
\end_layout

\begin_layout Enumerate
Three Dimmensional Matching asks the question: For the Cartesian product
 of three disjount sets 
\begin_inset Formula $X,Y,$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

, is there some subset of the product that has unique coordinates for all
 members of the set? Formally, 
\begin_inset Formula $X\times Y\times Z$
\end_inset

 = P, where the 
\begin_inset Formula $|X|=|Y|=|Z|=q$
\end_inset

, does there exists a matching 
\begin_inset Formula $M\subseteq P$
\end_inset

 such that for all members of 
\begin_inset Formula $M$
\end_inset

 no coordiates of the triple 
\begin_inset Formula $(x_{i},y_{i},z_{i})$
\end_inset

 are duplicated in any other element of 
\begin_inset Formula $M$
\end_inset

, with 
\begin_inset Formula $|M|=q$
\end_inset

? That is, for M = {
\begin_inset Formula $(x_{i},y_{i},z_{i})$
\end_inset

 ,
\begin_inset Formula $(x_{j},y_{j},z_{j}),$
\end_inset


\begin_inset Formula $\ldots,(x_{q},y_{q},z_{q})$
\end_inset

}, 
\begin_inset Formula $x_{i}\neq x_{j}$
\end_inset

, 
\begin_inset Formula $y_{i}\neq y_{j}$
\end_inset

, and 
\begin_inset Formula $z_{i}\neq z_{j}$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
Vertex Cover asks the question: Is there a vertex cover for a given graph
 
\begin_inset Formula $G$
\end_inset

 of size 
\begin_inset Formula $K$
\end_inset

 or less? A vertex cover is a set of vertices of a graph who are incident
 on edges which whose vertices make up all the vertices of the graph.
 Formally, for a graph 
\begin_inset Formula $G(V,E),$
\end_inset

 is there a vertex cover 
\begin_inset Formula $V'\subseteq V$
\end_inset

 such that 
\begin_inset Formula $|V'|\leq K$
\end_inset

, and for each edge 
\begin_inset Formula $\{u,v\}$
\end_inset

 
\begin_inset Formula $\epsilon$
\end_inset

 
\begin_inset Formula $E$
\end_inset

 either 
\begin_inset Formula $u$
\end_inset

 or 
\begin_inset Formula $v$
\end_inset

 belong to 
\begin_inset Formula $V'$
\end_inset

, but not both?
\end_layout

\begin_layout Enumerate
Clique asks the question: For a given graph 
\begin_inset Formula $G(V,E)$
\end_inset

 is there a strongly connected component of size 
\begin_inset Formula $J$
\end_inset

 or more in 
\begin_inset Formula $G$
\end_inset

? A strongly connected componenet is a set of vertices with a path between
 all pairs of vertices (i.e.
 a complete subgraph)
\end_layout

\begin_layout Enumerate
.Hamiltonian Circuit asks the question: Is there a cycle in the graph in
 which all vertices are visited only once? Formally, for a given graph 
\begin_inset Formula $G(V,E)$
\end_inset

, with 
\begin_inset Formula $V=\{v_{1},v_{2},\ldots v_{n}\}$
\end_inset

, where n = 
\begin_inset Formula $|V|$
\end_inset

.
 Is there an ordering of the members of 
\begin_inset Formula $V$
\end_inset

 such that 
\begin_inset Formula $\{v_{1,}v_{n}\}$
\end_inset

 
\begin_inset Formula $\epsilon$
\end_inset

 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $\{v_{i},v_{i+1}\}$
\end_inset

 
\begin_inset Formula $\epsilon$
\end_inset

 
\begin_inset Formula $V$
\end_inset

 for all 
\begin_inset Formula $i$
\end_inset

, 
\begin_inset Formula $1\leq i<n$
\end_inset

?
\end_layout

\begin_layout Enumerate
Partition asks the question: Is there some way to evenly dividing a set
 of elements such that the sum of their values is equivalent? Formally,
 for a given set of elements 
\begin_inset Formula $A=\{a_{1},a_{2},\ldots a_{n}\}$
\end_inset

, where 
\begin_inset Formula $weight(a_{i})$
\end_inset

 
\begin_inset Formula $\epsilon$
\end_inset


\begin_inset Formula $\mathbb{Z}^{+}$
\end_inset

, is there a set 
\begin_inset Formula $A'\subseteq A$
\end_inset

 such that:
\begin_inset Formula 
\[
{\displaystyle \sum_{a\epsilon A'}weight(a)=\sum_{a\epsilon A-A'}weight(a)}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/npcompleteTree.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:npCompleteTree"

\end_inset

This diagram depicts the hiearchy of the NP-completeness proofs in this
 section.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SAT to 3SAT
\end_layout

\begin_layout Subsection
3SAT to 3DIMM Matching
\end_layout

\begin_layout Subsection
3DIMM Matching to Partition
\end_layout

\begin_layout Subsection
3SAT to Vertex Cover
\end_layout

\begin_layout Subsection
Vertex Cover to Hamiltonian Circuit
\end_layout

\begin_layout Standard
For the given graph G, the graph 
\begin_inset Formula $G'$
\end_inset

 can be generated to demonstrate the equivalence of VC and HC.
 You can view both of these graphs in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:vcToHC"

\end_inset

.
\end_layout

\begin_layout Subsection
Vertex Cover to Clique
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/vcToHC.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:vcToHC"

\end_inset

 A polynomial time mapping reduction from a graph 
\begin_inset Formula $G$
\end_inset

 with a vertex cover of size 
\begin_inset Formula $|K|$
\end_inset

 allows us to generate a graph 
\begin_inset Formula $G'$
\end_inset

 which has a Hamiltonian circuit.
 Here 
\begin_inset Formula $K=\{a_{1}\}.$
\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Part
Algorithms
\end_layout

\begin_layout Section
Data Structures
\end_layout

\begin_layout Subsection
Graphs
\end_layout

\begin_layout Subsection
Trees
\end_layout

\begin_layout Subsection
Lists
\end_layout

\begin_layout Subsection
Queues
\end_layout

\begin_layout Subsection
Arrays
\end_layout

\begin_layout Section
Optimatility
\end_layout

\begin_layout Section
Approximation Algorithms
\begin_inset CommandInset label
LatexCommand label
name "sec:Approximation-Algorithms"

\end_inset


\end_layout

\begin_layout Subsection
Backtracking
\end_layout

\begin_layout Subsection
Branch and Bound
\end_layout

\begin_layout Subsection
Local Search
\end_layout

\begin_layout Section
Randomized Algorithms
\begin_inset CommandInset label
LatexCommand label
name "sec:Randomization-Algorithms"

\end_inset


\end_layout

\begin_layout Subsection
Las Vegas and Monte Carlo
\end_layout

\begin_layout Subsection
Game Theoretic Techniques
\end_layout

\begin_layout Subsection
Moments and Deviations
\end_layout

\begin_layout Subsection
Tail Inequalities
\end_layout

\begin_layout Subsection
The Probablistic Method
\end_layout

\begin_layout Section
Dynamic Programming
\begin_inset CommandInset label
LatexCommand label
name "sec:Dynamic-Programming"

\end_inset


\end_layout

\begin_layout Subsection
Recurrence Relations
\end_layout

\begin_layout Subsection
Memoization
\end_layout

\begin_layout Section
Fast Fourier Transform
\begin_inset CommandInset label
LatexCommand label
name "sec:Fast-Fourier-Transform"

\end_inset


\end_layout

\begin_layout Section
Shortest Path Algorithms
\end_layout

\begin_layout Subsection
Dijkstra
\end_layout

\begin_layout Subsection
Bellman-Ford
\end_layout

\begin_layout Section
Maximum Flow
\begin_inset CommandInset label
LatexCommand label
name "sec:Maximum-Flow"

\end_inset


\end_layout

\begin_layout Subsection
Flows and Cuts
\end_layout

\begin_layout Subsection
The Max-Flow Min-Cut Theorem
\end_layout

\begin_layout Subsection
Flow Networks, Residual Networks, and Augmenting Flows
\end_layout

\begin_layout Subsection
Ford-Fulkerson Algorithm
\end_layout

\begin_layout Subsection
The Scaling Algorithm
\end_layout

\begin_layout Subsection
Edmonds-Karp Algorithm
\end_layout

\begin_layout Subsection
Dinic's Algorithm
\end_layout

\begin_layout Section
Bipartite Matching
\begin_inset CommandInset label
LatexCommand label
name "sec:Bipartite-Matching"

\end_inset


\end_layout

\begin_layout Subsection
Nomencalture– Matchings, Perfect Matchings, Maximum Matchings, and Bipartiteness
\end_layout

\begin_layout Subsection
The Frobenius-Hall Theorem
\end_layout

\begin_layout Subsection
Hopcroft-Karp Algorithm
\end_layout

\begin_layout Subsection
The Hungarian Algorithm
\end_layout

\begin_layout Section
Appendix: Reference Material
\begin_inset CommandInset label
LatexCommand label
name "sec:Appendix:-Reference-Material"

\end_inset


\end_layout

\begin_layout Standard
The following sections provide some useful resources that will help you
 along the way.
 
\end_layout

\begin_layout Subsection
Software
\end_layout

\begin_layout Itemize
Draw.io is a online tool for creating all sorts of diagrams.
 It will be useful when creating automata.
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.draw.io
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
LyX is a \SpecialChar LaTeX
 word processing application that will be useful when drafting
 homework.
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.lyx.org
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Python is a useful programming language for experimenting with algorithms.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.python.org
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Mendeley is a good tool to organize your electronic library of books and
 journal articles.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.mendeley.com/
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Mathematica or MatLab to help your with linear programming 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://software.oit.gatech.edu
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Books
\end_layout

\begin_layout Standard
Even if you buy all these books it will not make you any better.
 I strongly suggest you acquire these for free and purchase the ones you
 find useful at a later date.
\end_layout

\begin_layout Itemize

\emph on
How to Prove It: A Structured Approach
\emph default
 by Daniel J.
 Velleman 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0521675995
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Mathematical Reasoning: Writing and Proof
\emph default
 by Ted Sundstrom 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/1500143413
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Book of Proof
\emph default
 by Richard Hammack 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0989472108
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Understanding Analysis
\emph default
 by Stephen Abbot 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/1493927116
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Introduction to Probability
\emph default
 by Dimitri P.
 Bertsekas and John N.
 Tsitsiklis 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/188652923X
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Discrete Mathematics and Its Applications
\emph default
 by Kenneth Rosen 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0073383090
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Introduction to the Theory of Computation
\emph default
 by Michael Sipser 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/113318779X
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Introduction to Automata Theory, Languages and Computation
\emph default
 by John Hopcroft, Rajeev Motwani and Jeffery Ullman 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0321455363
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Computers and Intractability: A Guide to the Theory of NP-Completeness
\emph default
 by Michael Garey and David Johnson 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0716710455
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Algorithm Design
\emph default
 by Jon Kleinberg and Eva Tardos 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0321295358
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Algorithms
\emph default
 by Sanjoy Dasgupta, Christos Papadimitriou, and Vijay Vazirani 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0073523402
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Introduction to Algorithms
\emph default
 by Thomas Cormen, Charles Leiserson, Ronald Rivest, and Clifford Stein
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0262033844
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Approximation Algorithms
\emph default
 by Vijay Vazirani 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/3540653678
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Randomized Algorithms
\emph default
 by Rajeev Motwani and Raghavan Prabhakar 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0521474655
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Linear Algebra and Its Applications 
\emph default
by David C.
 Lay 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/032198238X
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Linear and Nonlinear Programming
\emph default
 by David Luenberger and Ye Yingyu 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/3319188410
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Videos
\end_layout

\begin_layout Itemize
Professor Harry Porter's YouTube playlist on the theory of computation.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.youtube.com/playlist?list=PLbtzT1TYeoMjNOGEiaRmm_vMIwUAidnQz
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Professor Tim Roughgardener's playlist on Logic 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.youtube.com/playlist?list=PLLH73N9cB21Xsgy39DP3xDqBN3lTaR8R5
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
Professor Tim Roughgardener's playlist on Data Structures and Algorithms
 I 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.youtube.com/playlist?list=PLLH73N9cB21W1TZ6zz1dLkyIm50HylGyg
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
Professor Tim Roughgardener's playlist on Data Structures and Algorithms
 II 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.youtube.com/playlist?list=PLLH73N9cB21VPj3H2xwTTye5TC8-UniA2
\end_layout

\end_inset


\end_layout

\end_body
\end_document
