#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin "C:/Users/DurepoBrandonA/OneDrive - Georgia Institute of Technology/CCA/Notes/"
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Computability, Complexity, and Algorithms Course Notes"
\pdf_author "Brandon A. Durepo"
\pdf_keywords "Algorithms, Automata, Computabilty, Complexity, Analysis"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Hitchhiker's Guide to Computability, Complexity, and Algorithms 
\end_layout

\begin_layout Author
Brandon A.
 Durepo, 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

bdurepo@gatech.edu
\end_layout

\end_inset


\end_layout

\begin_layout Quote
\noindent
\align right
\begin_inset Quotes eld
\end_inset

Don't Panic.
\begin_inset Quotes erd
\end_inset

 – Douglas Adams
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
The purpose of this document is to help students of all stripes succeed
 in Georgia Tech's course on Computability, Complexity and Algorithms more
 formally known as CS6505.
 Many students find this course to be challenging and the topics can be
 opaque at times to the newcomer.
 However with grit, determination, and luck you, the reader, can reap the
 many benefits that this course offers.
 In proceeding sections I outline some of the key concepts you will need
 to be successful in the course.
 I make no assumptions about prerequisite knowledge and attempt to provide
 you the green field perspective on the subject matter.
 In many cases, if you have already seen the information it is safe to skip
 forward and not concern yourself what may be obvious to you, but I encourage
 you to read all the sections because additional clarity may be gained with
 another pass through.
\end_layout

\begin_layout Section
Elementary Logic and Truth Tables
\end_layout

\begin_layout Section
Propositional and Sentential Logic
\begin_inset CommandInset label
LatexCommand label
name "sec:propositionalSententialLogic"

\end_inset


\end_layout

\begin_layout Section
Sets
\begin_inset CommandInset label
LatexCommand label
name "sec:Sets"

\end_inset


\end_layout

\begin_layout Section
Quantification Logic
\begin_inset CommandInset label
LatexCommand label
name "sec:quantificationLogic"

\end_inset


\end_layout

\begin_layout Section
Writing Proofs
\begin_inset CommandInset label
LatexCommand label
name "sec:writingProofs"

\end_inset


\end_layout

\begin_layout Section
Relations
\begin_inset CommandInset label
LatexCommand label
name "sec:Relations"

\end_inset


\end_layout

\begin_layout Section
Functions
\begin_inset CommandInset label
LatexCommand label
name "sec:Functions"

\end_inset


\end_layout

\begin_layout Section
Induction
\begin_inset CommandInset label
LatexCommand label
name "sec:Induction"

\end_inset


\end_layout

\begin_layout Section
Deterministic Finite Automata
\begin_inset CommandInset label
LatexCommand label
name "sec:deterministicFiniteAutomata"

\end_inset


\end_layout

\begin_layout Standard
Finite automata are a systems of information represented by states, transitions,
 and inputs.
 Information about the computation is derived from the state in which the
 automata exists and no previous information can be remembered by the finite
 automata.
 The limits to which the finite automata can model information are expressed
 by the number of states.
\end_layout

\begin_layout Subsection
Notation of DFA's
\begin_inset CommandInset label
LatexCommand label
name "subsec:Notation-of-DFA's"

\end_inset


\end_layout

\begin_layout Standard
Traditionally finite automata
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
automata
\end_layout

\end_inset

 are expressed by a tuple of sets which express its behavior.
 The tuple, for example 
\begin_inset Formula $L=(Q,\Sigma,\delta,q_{0},F)$
\end_inset

, contains information on the states expressed by the set Q, the input alphabet
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
alphabet
\end_layout

\end_inset

 expressed by the set 
\begin_inset Formula $\Sigma$
\end_inset

, the transitions
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
transitions
\end_layout

\end_inset

 expressed by the function 
\begin_inset Formula $\delta$
\end_inset

, the starting state given by 
\begin_inset Formula $q_{0}$
\end_inset

, and the set of final states given by 
\begin_inset Formula $F$
\end_inset

.
 An example of a finite automata can be seen in Figure
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:productDFA"

\end_inset

.
 Strings are typically represented by variables of lowercase letters at
 the end of the alphabet ( w, x, y, and z) whereas characters are represented
 variables of lowercase letters at the beginning of the English alphabet
 ( a, b, and c).
 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 represents the set of all strings over the alphabet 
\begin_inset Formula $\Sigma$
\end_inset

 including the empty string–the super-script star symbol is referred to
 as the Kleene star
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
Kleene star
\end_layout

\end_inset

.
 The empty string is denoted by the epsilon symbol 
\begin_inset Formula $\epsilon$
\end_inset

.
 The empty string denotes a string of length 0, a string of no characters.
 Length is often expressed by vertical bars surrounding the string in question,
 such as 
\begin_inset Formula $|w|$
\end_inset

.
 A transition function 
\begin_inset Formula $\delta$
\end_inset

 takes two parameters, a state and an input symbol, and returns the next
 state to which the automaton should transition on input of the symbol (
 i.
 e 
\begin_inset Formula $\delta(q,$
\end_inset

a)).
 
\end_layout

\begin_layout Subsection
Computation of DFA's
\begin_inset CommandInset label
LatexCommand label
name "subsec:Computation-of-DFA's"

\end_inset


\end_layout

\begin_layout Standard
Given a finite automata, computation can be carried out on an input string
 by processing each character of the input one-by-one and following the
 transitions based on the input character.
 by Upon encountering the last character in the input string computation
 stops and based on whether the state is a final state (accepting state)
 or a nonaccepting state, the string is either accepted or rejected.
 Accepted strings are said to be in the language of the automaton rejected
 strings are not in the language.
 Given an automaton 
\begin_inset Formula $A$
\end_inset

 the language of 
\begin_inset Formula $A$
\end_inset

 is denoted 
\begin_inset Formula $L(A)$
\end_inset

.
 A language is a subset of 
\end_layout

\begin_layout Subsection
Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:Regular-Languages"

\end_inset


\end_layout

\begin_layout Standard
A language is a regular language
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
regular language
\end_layout

\end_inset

 if it is accepted by some 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
deterministic finite automata (DFA
\end_layout

\end_inset

deterministic finite automata (DFA).
 A caveat here is that the DFA must accept only those strings in the language
 it models and no others.
 Nonregular languages are those that cannot be modeled by a DFA.
 Examples of nonregular languages are those that require automata to count
 beyond a finite number of states.
 The classical example is the language L = {
\begin_inset Formula $0^{n}1$
\end_inset


\begin_inset Formula $^{n}$
\end_inset

 | 
\begin_inset Formula $n\geq1$
\end_inset

}.
 DFA's cannot check for the same number of symbols in a string or balanced
 parenthesis.
 This job falls to context free grammars.
\end_layout

\begin_layout Section
Nondeterministic Finite Automata
\begin_inset CommandInset label
LatexCommand label
name "sec:Nondeterministic-Finite-Automata"

\end_inset


\end_layout

\begin_layout Standard
A 
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
nondeterministic finite automaton (NFA)
\end_layout

\end_inset

nondeterministic finite automaton (NFA) differs from its deterministic counterpa
rt in that it may be in many states at once.
 Transitions on an input symbol may proceed to any number states.
 This idea is demonstrated in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:nfaExample"

\end_inset

.
 NFA's are equivalent to DFA's and such anything that can be modeled with
 a NFA can be modeled with a DFA.
 Thus, the class of languages modeled by NFA's is the regular languages.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/nfaExample.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:nfaExample"

\end_inset

The NFA depicted in the diagram shows that on input symbol 
\begin_inset Formula $a$
\end_inset

the automaton transitions to the state 
\begin_inset Formula $q_{1},q_{2}$
\end_inset

 and 
\begin_inset Formula $q_{3}$
\end_inset

 at the same time.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Proof of Equivalence of NFA's and DFA's
\begin_inset CommandInset label
LatexCommand label
name "subsec:Proof-of-Equivalence"

\end_inset


\end_layout

\begin_layout Standard
The proof of equivalence between DFA's and NFA's is often called the Subset
 Construction.
 In the succeeding proof given a NFA the states 
\begin_inset Formula $Q_{N}$
\end_inset

, inputs 
\begin_inset Formula $\Sigma$
\end_inset

, transition function 
\begin_inset Formula $\delta_{N}$
\end_inset

, start state q, and final states 
\begin_inset Formula $F$
\end_inset

.
 The set of states of the constructed DFA 
\begin_inset Formula $Q_{D}$
\end_inset

 = 2
\begin_inset Formula $^{Q_{N}}$
\end_inset

, that is the power set of the set of states of the NFA.
 A power set of a set is defined as the set of all possible subsets of a
 given set.
 The inputs to the DFA will be the same as the inputs of the NFA, 
\begin_inset Formula $\Sigma$
\end_inset

.
 The start state of the DFA is the set containing the start state, 
\begin_inset Formula $q_{0}$
\end_inset

 of the NFA.
 The DFA states are named such that they enumerate the powerset's subsets
 with labels that correspond to the states of the NFA.
 The transition function for the DFA, 
\begin_inset Formula $\delta_{D}$
\end_inset

 is defined by 
\begin_inset Formula $\delta_{D}(\{q_{1,}q_{2},\ldots q_{k}\},a)$
\end_inset

 is the union over all i, for i = 1
\begin_inset Formula $\ldots k$
\end_inset

 of the NFA's transition function 
\begin_inset Formula $\delta_{N}(q_{i},a)$
\end_inset

.
 To prove equivalence of the DFA and NFA representation we must show that
 
\begin_inset Formula $\delta_{N}(q_{0},w)=\delta_{D}(\left\{ q_{0}\right\} ,w)$
\end_inset

.
 The proof is an induction on the string 
\begin_inset Formula $w$
\end_inset

.
 For the basis step we take 
\begin_inset Formula $w=\epsilon$
\end_inset

 : 
\begin_inset Formula $\delta_{N}(q_{0},\epsilon)=\delta_{D}(\left\{ q_{0}\right\} ,\epsilon)=\{q_{0}\}$
\end_inset

 .
 This is true by the basis rule for extending the delta function for NFA's
 and DFA's.
 We assume that the inductive hypothesis holds from strings shorter than
 
\begin_inset Formula $w$
\end_inset

.
 Let 
\begin_inset Formula $w=xa$
\end_inset

.
 The inductive hypothesis holds from the string 
\begin_inset Formula $x$
\end_inset

.
 Let 
\begin_inset Formula $\delta_{N}(q_{0},x)=\delta_{D}(\{q_{0}\},x)=S.$
\end_inset

 
\begin_inset Formula $S$
\end_inset

 represents a label for a set of states of the NFA.
 Let 
\begin_inset Formula $T$
\end_inset

 be the union over all states 
\begin_inset Formula $p$
\end_inset

 in 
\begin_inset Formula $S$
\end_inset

 of 
\begin_inset Formula $\delta_{N}(p,a).$
\end_inset

 Then 
\begin_inset Formula $\delta_{N}(q_{0},w)=\delta_{D}(\{q_{0}\},w)=T$
\end_inset

 by the rule for extending delta functions of NFA's and DFA's.
 Thus, DFA's and NFA's are equivalent.
\end_layout

\begin_layout Subsection
Conversion from NFA to DFA
\begin_inset CommandInset label
LatexCommand label
name "subsec:Conversion-from-NFA"

\end_inset


\end_layout

\begin_layout Standard
An example of a transition function on a chess board shown in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:chessBoard"

\end_inset

 is given by the NFA's transition table in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:convertNFA2DFA"

\end_inset

.
 An equivalent DFA transition table is given by the adjoining table in the
 diagram.
 A lazy conversion technique can be carried out to only include the state
 sets in the DFA only when necessary.
 An automaton modeling the NFA representation of the chess board is depicted
 in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:chessNFA2"

\end_inset

.
 A corresponding DFA automaton representation is depicted in Figure
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/chessBoard.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:chessBoard"

\end_inset

 A traditional chess board enumerating the black and red squares with odd
 and even numbers, respectively.
 In this board a transition onto state 
\begin_inset Formula $9$
\end_inset

 constitutes an accepting state.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NFA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4,6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,3,5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,5,7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,4,6,8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,3,7,9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,5,9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4,8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4,6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5,7,9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6,8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DFA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
b
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 5\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1,3,5,7\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 5\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1,3,7,9\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1,3,5,7,9\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1,3,5,7\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1,3,5,7,9\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\begin_inset Formula $\left\{ 1,3,7,9\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 5\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
*
\begin_inset Formula $\left\{ 1,3,5,7,9\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\left\{ 1,3,5,7,9\right\} $
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:convertNFA2DFA"

\end_inset

 In the transition table for either the NFA or DFA.
 Odd numbered states can be viewed as the black squares of a chess board
 while even numbered states are the red squares.
 Note that the list of states in the NFA transitions expresses the fact
 that the NFA transitions to the enumerated states simultaneously, while
 the DFA bracketed states express the label of the single state to which
 the DFA transitions on the input symbol.
 In the DFA table the state set label 
\begin_inset Formula $\left\{ 2,4\right\} $
\end_inset

 is assigned the state 
\begin_inset Formula $\left\{ 2,4,6,8\right\} $
\end_inset

 on input r because it represents the union of the transitions of the states
 to which the NFA will transition to on input r from either state 2 or 4.
 This logic applies for all other states set given in the DFA table as well.
 Star symbols in either table indicate a final state.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename C:/Users/DurepoBrandonA/OneDrive/Diagrams/chessNFA2.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:chessNFA2"

\end_inset

 The chess NFA automaton.
 Transitions from odd numbers to even numbers occur on the input symbol
 
\begin_inset Formula $r$
\end_inset

.
 Transitions from even numbers to odd numbers occur on input symbol 
\begin_inset Formula $b$
\end_inset

.
 Transition labels have been ommited for the sake of clarity.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/chessDFA.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:chessDFA"

\end_inset

 The chess DFA automaton.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset Formula $\epsilon-$
\end_inset

NFA's
\begin_inset CommandInset label
LatexCommand label
name "sec:epsilonNFA's"

\end_inset


\end_layout

\begin_layout Standard
NFA's that allow for epsilon transitions are called epsilon NFA.
 Epsilon transitions allow for an automaton to transition between states
 without regard to the input string.
 Effectively, it allows for the computation to skip forward in the automaton
 without processing input.
 An example of an epsilon NFA is depicted in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:epsilonNFA"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/epsilonNFA.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:epsilonNFA"

\end_inset

 Epsilon transitions are marked with a 
\begin_inset Formula $\epsilon$
\end_inset

symbol.
 Upon transitioning to state 
\begin_inset Formula $q_{2}$
\end_inset

 the automaton spontaneously and in parallel transitions to states 
\begin_inset Formula $q_{1}$
\end_inset

, 
\begin_inset Formula $q_{3}$
\end_inset

 and 
\begin_inset Formula $q_{5}$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Closure of States
\begin_inset CommandInset label
LatexCommand label
name "subsec:Closure-of-States"

\end_inset


\end_layout

\begin_layout Standard
The closure of states is defined as the set of states reachable from state
 in question.
 The function is traditionally denoted 
\begin_inset Formula $CL(q).$
\end_inset

 The closure of state 
\begin_inset Formula $q2$
\end_inset

 in Figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:epsilonNFA"

\end_inset

 is 
\begin_inset Formula $\left\{ q2,q1,q3,q5\right\} $
\end_inset

.
\end_layout

\begin_layout Section
Regular Expressions
\begin_inset CommandInset label
LatexCommand label
name "sec:Regular-Expressions"

\end_inset


\end_layout

\begin_layout Standard
Regular expressions use three operations: union, concatenation, and Kleene
 star.
 Concatenation on languaguages 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

is denoted 
\begin_inset Formula $LM.$
\end_inset

 
\begin_inset Formula $LM$
\end_inset

 is defined as 
\begin_inset Formula $wx$
\end_inset

 where 
\begin_inset Formula $w\varepsilon L$
\end_inset

 and 
\begin_inset Formula $x\varepsilon M$
\end_inset

.
 Kleene star (
\begin_inset Formula $^{*})$
\end_inset

 is the set of strings formed by concatenating 0 or more strigns of 
\begin_inset Formula $L$
\end_inset

 in any order.
 The Kleene star of 
\begin_inset Formula $L$
\end_inset

 is then 
\begin_inset Formula $L^{*}=\left\{ \epsilon\right\} \cup L\cup LL\ldots$
\end_inset

 
\end_layout

\begin_layout Subsection
Precedence of Operators on Regular Expressions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Precedence-of-Operators"

\end_inset


\end_layout

\begin_layout Enumerate
Parenthesis
\end_layout

\begin_layout Enumerate
Kleene star
\end_layout

\begin_layout Enumerate
Concatenation
\end_layout

\begin_layout Enumerate
Union
\end_layout

\begin_layout Subsection
Algebraic Laws and Identities of Regular Expressions
\begin_inset CommandInset label
LatexCommand label
name "subsec:algebraicLawsAndIdentitesRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
Union is communative and associative.
 Concatenation is associative however is not communative.
\begin_inset Formula $\emptyset$
\end_inset

 is the identity for union.
\begin_inset Formula $\epsilon$
\end_inset

is the identity for concatenation.
 
\begin_inset Formula $\emptyset$
\end_inset

 is the annihilator for concatenation.
\end_layout

\begin_layout Section
Properties of Language Classes
\begin_inset CommandInset label
LatexCommand label
name "sec:propertiesOfLanguages"

\end_inset


\end_layout

\begin_layout Standard
A language class is a set of languages, and language classes have two important
 properties.
\end_layout

\begin_layout Itemize
Decision properties
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
decision properties
\end_layout

\end_inset

 - algorithms that when applied to a language determine whether a certain
 property holds (e.g.
 is a language empty).
\end_layout

\begin_layout Itemize
Closure properties
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
closure properties
\end_layout

\end_inset

 - describes the operations in which when applied to a language class produce
 another language in the same language class (e.g.
 union)
\end_layout

\begin_layout Subsection
Decision Properties of Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:DecisionPropertiesOfRegularLanguages"

\end_inset


\end_layout

\begin_layout Subsubsection
The Membership Test for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:membershipTestForRegularLanguages"

\end_inset

 
\end_layout

\begin_layout Standard
The classic decision property for languages is the Membership Test.
 That is, is a given string w in the language.
 The algorithm to determine this is simply to simulate the string on the
 DFA of the language.
 If the simulation of w on the DFA ends in an accepting state, then the
 string is in the language, otherwise the string has ended in a non-accepting
 state of the DFA and it is thus not in the language.
 
\end_layout

\begin_layout Subsubsection
The Emptiness Test for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:emptinessTestForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
Another example of decision properties is the Emptiness Problem.
 That is given a regular language, does it contain any strings at all? To
 determine whether the language has any strings first obtain the DFA-representat
ion of the language and then compute the reachable states from the start
 state.
 A good way of doing this is Breadth-First Search on the graph of the DFA.
 If a accepting state is reachable from the start state then we know that
 at least one string is in the language.
\end_layout

\begin_layout Subsubsection
The Equivalence Test for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:equivalenceTestForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
Another example of decision properties is testing whether two languages,
 L and M, are equivalent.
 Their DFA's are specified as follows: 
\begin_inset Formula $L=(Q,\Sigma,\delta_{L},A,F_{L})$
\end_inset

 and 
\begin_inset Formula $M=(R,\Sigma,\delta_{M},C,F_{M})$
\end_inset

 where 
\begin_inset Formula $Q=\{A,B\}$
\end_inset

, 
\begin_inset Formula $R=\left\{ C,D\right\} $
\end_inset

, and 
\begin_inset Formula $\Sigma=\{0,1\}$
\end_inset

.
 The transition function on each DFA, L and M can be seen in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:productDFA"

\end_inset

.
 To test equivalence one may form a product on the states of each DFA such
 that for each respective state in Q and R the product DFA's state set is
 
\begin_inset Formula $Q\times R$
\end_inset

 has a corresponding state.
 The start state for the product DFA would then be the pair 
\begin_inset Formula $\left[q_{0},r_{0}\right]$
\end_inset

 .
 The transition function would then be formed as follows: 
\begin_inset Formula $\delta(\left[q,r\right],1)=\left[\delta_{L}(q,1),\delta_{M}(r,1)\right]$
\end_inset

.
 The product DFA N pictured in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:productDFA"

\end_inset

 is assigned final states such that either the one of the state pair's respectiv
e DFA enters a final state, but not both.
 For example, the state B is a final state in the DFA L, and the state C
 is a final state in the DFA M.
 The state pair (B,D) is then marked final in the DFA N instead of (B,C)
 because the state D is not a final state in the DFA M.
 Similarly, the state pair (A,C) is marked a final state in the DFA N because
 C in final state the DFA M, but A is not a final state in the DFA L.
 This feature of only one state being accepting is used a differentiating
 characteristic to determine whether the languages of the DFA's L and M
 are equivalent.
 The languages L and M are equivalent if and only if the language of N is
 empty.
 This means that N models the feature that neither L accepts when M does
 not, nor does M accept when L does not.
 It is clear from the that the empty string 
\begin_inset Formula $\epsilon$
\end_inset

 is accepted by M and not by L and is so modeled by the pair (A,C) in N.
 N accepts the empty string and therefore, L and M are not equivalent languages.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/productDFA.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:productDFA"

\end_inset

The transition function formed on newly formed state set of 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $Q\times R$
\end_inset

 corresponds to the transitions of L and M.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The Infiniteness Test for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:infinitenessTestRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
A final example of decision problems fro regular languages in the Infiniteness
 Problem.
 The problem asks, is the given regular language composed of an infinite
 number of strings? We can determine if a given language is infinite by
 examining the DFA-representation of the language.
 If the DFA has n states, and the given language has a string of n or more
 in length, then the language is infinite.
 Otherwise, the language must be finite.
 (If a language has a string of length n or more, then surely the DFA contains
 a cycle that yielded such a string).
 The proof of this idea follows: If there is a n-state DFA that accepts
 a string w of length n or more, then there must be a state that appears
 twice on the path traced out by the simulation of w on the DFA from the
 start state to the final state.
 This is because for all strings w of length n a DFA must traverse n+1 states.
 A diagram of the automaton demonstrating this principle can be seen in
 Figure 
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:pumpingLemma"

\end_inset

.
\end_layout

\begin_layout Standard
\noindent
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/pumpingLemma.svg
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pumpingLemma"

\end_inset

In the automaton pictured above a string w is formed by the the substrings
 x, y, and z.
 The substring x is the substring that takes us to the first cycle in the
 automaton.
 The cycle occurs at state q.
 The edge labeled y represents the edge which returns the string w to state
 q for the first time.
 Because the substring y is locked within the string w, that is its prefix
 is the substring x and its postfix is the substring z, it cannot be the
 empty string.
 However, the substrings x or z may be the empty string.
 Then 
\begin_inset Formula $xy^{i}z$
\end_inset

 for all 
\begin_inset Formula $i\geq0$
\end_inset

 is in the language, and therefore an infinite number of strings exist in
 the language.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Claim: If there is a string of length 
\begin_inset Formula $\geq n$
\end_inset

 in L, then there is a string of length 
\begin_inset Formula $\left[n,2n-1\right]$
\end_inset

 .
 
\end_layout

\begin_layout Standard
Proof: Because y is the first cycle on the path to the accepting state,
 the length 
\begin_inset Formula $|xy|\leq n$
\end_inset

, and more specifically, 
\begin_inset Formula $1\leq|y|\leq n$
\end_inset

 ( x and z may be empty strings).
 Some state along the path xy surely must repeat.
 If w is the shortest possible string of length n, then it cannot be longer
 than 2n.
 However, suppose it was.
 The string xz is another accepted string in the language.
 We know that xz = w - y, and the length of 
\begin_inset Formula $y\leq n$
\end_inset

, so the length of 
\begin_inset Formula $xz\geq n$
\end_inset

.
 Which means that 
\begin_inset Formula $|xz|\leq|w|$
\end_inset

, and yet at least n in length which is accepted, but we assumed that the
 were no strings that were shorter than w and of length at least n.
 Thus, if the string w were of length 
\begin_inset Formula $\geqq2n$
\end_inset

 , there is a shorter string of length 
\begin_inset Formula $\left[n,2n-1\right]$
\end_inset

 formed by removing the substrings represented by y which are 
\begin_inset Formula $\left[1,n\right]$
\end_inset

 .
 
\end_layout

\begin_layout Subsection
Closure Properties of Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:closurePropertiesOfRegularLanguages"

\end_inset


\end_layout

\begin_layout Subsubsection
Union for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:UnionForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are regular languages, then 
\begin_inset Formula $L\cup M$
\end_inset

 is also a regular language.
 The proof of this statement is as follows: Let the languages 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 be the languages of the regular expressions 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 respectively, then 
\begin_inset Formula $R+S$
\end_inset

 is a regular expression whose language is the 
\begin_inset Formula $L\cup M$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Intersection for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:IntersectionForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are regular languages, then 
\begin_inset Formula $L\cap M$
\end_inset

 is also a regular language.
 The proof of this statement is as follows: Let 
\begin_inset Formula $I$
\end_inset

 and 
\begin_inset Formula $J$
\end_inset

 be the DFA's for the regular languages 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, respectively.
 Form the product DFA 
\begin_inset Formula $K$
\end_inset

 of 
\begin_inset Formula $I$
\end_inset

 and 
\series bold

\begin_inset Formula $J$
\end_inset

 
\series default
and mark the final states of 
\begin_inset Formula $K$
\end_inset

 as the states in which both 
\begin_inset Formula $I$
\end_inset

 and 
\begin_inset Formula $J$
\end_inset

 are in final states.
 The DFA 
\begin_inset Formula $K$
\end_inset

 is now a regular language representing 
\begin_inset Formula $L\cap M$
\end_inset

.
 This idea is demonstrated in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:intersectionDFA"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/intersectionDFA.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:intersectionDFA"

\end_inset

The product DFA 
\begin_inset Formula $K$
\end_inset

 represents the intersection of 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 and its final state is the state pair for which a final state exists for
 both 
\begin_inset Formula $I$
\end_inset

 and 
\begin_inset Formula $J$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Difference for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:DifferenceForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are regular languages, then 
\begin_inset Formula $L-M$
\end_inset

 is also a regular language.
 
\begin_inset Formula $L-M$
\end_inset

 represents the strings that are in 
\begin_inset Formula $L$
\end_inset

 but not in 
\begin_inset Formula $M$
\end_inset

.
 The proof of this statement is as follows: Let 
\begin_inset Formula $I$
\end_inset

 and 
\begin_inset Formula $J$
\end_inset

 be the DFA's for the regular languages 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

, respectively.
 Form the product DFA 
\begin_inset Formula $K$
\end_inset

 of 
\begin_inset Formula $I$
\end_inset

 and 
\series bold

\begin_inset Formula $J$
\end_inset

 
\series default
and mark the final states of 
\begin_inset Formula $K$
\end_inset

 as the states in which 
\begin_inset Formula $I$
\end_inset

 is in a final state and 
\begin_inset Formula $J$
\end_inset

 is not in a final state.
 The DFA 
\begin_inset Formula $K$
\end_inset

 now represents 
\begin_inset Formula $L-M$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Concatenation for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:ConcatenationForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 are regular languages, then 
\begin_inset Formula $LM$
\end_inset

 is also a regular language.
 The proof of this statement is as follows: Let the languages 
\begin_inset Formula $L$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 be the languages of the regular expressions 
\begin_inset Formula $R$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 respectively, then 
\begin_inset Formula $RS$
\end_inset

 is a regular expression whose language is the 
\begin_inset Formula $LM$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Kleene Closure for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:KleeneClosureForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $R^{*}$
\end_inset

 is a regular expression whose language is 
\begin_inset Formula $L^{*}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Complement for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:ComplementForRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
The complement of a language 
\begin_inset Formula $L$
\end_inset

 with respect to an alphabet 
\begin_inset Formula $\Sigma$
\end_inset

 such that 
\begin_inset Formula $\Sigma^{*}$
\end_inset

contains 
\begin_inset Formula $L$
\end_inset

 is the difference of 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 and the language 
\begin_inset Formula $L$
\end_inset

.
 Since 
\begin_inset Formula $\Sigma^{*}$
\end_inset

 is surely a regular language, and regular languages are closed under difference
 as we have seen previously, then the complement 
\begin_inset Formula $\Sigma^{*}-L$
\end_inset

 is also regular.
\end_layout

\begin_layout Section
Conversion of Language Representations
\begin_inset CommandInset label
LatexCommand label
name "subsec:conversionOfLanguageRepresentations"

\end_inset


\end_layout

\begin_layout Standard
A cycle is formed on the way in which we can represent languages.
 There exists algorithms to convert from one representation to the next
 along the cycle depicted in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:representationCycle"

\end_inset

.
 As such, given a regular expression one may convert it to a DFA.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/representationCycle.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:representationCycle"

\end_inset

 This diagram describes the conversion cycle of representations such that
 from a regular expression it is possible to obtain a DFA.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
DFA Minimization
\begin_inset CommandInset label
LatexCommand label
name "sec:DFA-Minimization"

\end_inset


\end_layout

\begin_layout Standard
Minimizing a DFA can be carried out in a naive way by enumerating all smaller
 DFA's for any given DFA and checking for equivalence.
 However, this is terribly inefficient and a smarter algorithm can be used
 to generate a equivalent DFA much faster.
\end_layout

\begin_layout Subsection
DFA Minimization Algorithm
\begin_inset CommandInset label
LatexCommand label
name "subsec:DFA-Minimization-Algorithm"

\end_inset


\end_layout

\begin_layout Standard
The key idea here is to create a table used to find distinguishable states.
 Distinguishable state pairs are those that have one member of the pair
 in an accepting state while the other is not in an accepting state.
 The table used to distinguish these pairs is formed by the product of the
 DFA's states, 
\begin_inset Formula $Q\times Q$
\end_inset

.
 If states can be distinguished then they represent a state in minimum DFA,
 while those that are indistinguishable can be merged into a single state.
 Effectively, we are recursively finding the shortest distinguishable string
 for a DFA.
\end_layout

\begin_layout Section
The Pumping Lemma for Regular Languages
\begin_inset CommandInset label
LatexCommand label
name "sec:pumpingLemmaRegularLanguages"

\end_inset


\end_layout

\begin_layout Standard
For every regular language L, there is an integer n, which happens to be
 the number of states in the DFA of L, such that for every w in L of length
 
\begin_inset Formula $\geq n$
\end_inset

.
 We can write w = xyz such that the following properties hold:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $|xy|\leq n$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $|y|>0$
\end_inset


\end_layout

\begin_layout Enumerate
For all 
\begin_inset Formula $i\geq0$
\end_inset

, 
\begin_inset Formula $xy^{i}z$
\end_inset

 is in L.
\begin_inset CommandInset label
LatexCommand label
name "enu:PumpingLemmaProperty3"

\end_inset


\end_layout

\begin_layout Standard
The Pumping Lemma is useful in determining whether a language is regular
 or nonregular.
\end_layout

\begin_layout Subsection
Using the Pumping Lemma to Prove a Language is Nonregular
\begin_inset CommandInset label
LatexCommand label
name "subsec:usingThePumpingLemmaToProveALanguageIsNonregular"

\end_inset


\end_layout

\begin_layout Paragraph
Claim: L = {
\begin_inset Formula $0^{k}1$
\end_inset


\begin_inset Formula $^{k}$
\end_inset

 | 
\begin_inset Formula $k\geq1$
\end_inset

} is a nonregular language.
\end_layout

\begin_layout Standard
Proof: Suppose for the purposes of contradiction that L is a regular language,
 then there exists an n for which the properties of the Pumping Lemma hold
 true.Let w = 
\begin_inset Formula $0^{n}1$
\end_inset


\begin_inset Formula $^{n}$
\end_inset

.
 The string w can be written in the form w = xyx where each component x,
 y, z forms some substring of w where x and consist of 0's and 
\begin_inset Formula $y\not=\epsilon$
\end_inset

, and z is composed of 1's.
 However, for this to be a regular language all the properties of the Pumping
 Lemma must hold true.
 In particular particular property
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:PumpingLemmaProperty3"

\end_inset

.
 For 
\begin_inset Formula $i=2$
\end_inset

, 
\begin_inset Formula $w=xyyz$
\end_inset

.
 The string formed by this construction contains more 0's than 1's, violating
 the conditions on the language as specified in the set former.
 Similarly, if yz and consist of 1's and 
\begin_inset Formula $y\not=\epsilon$
\end_inset

, the string formed by this construction contains more 1's than 0's again
 violating the conditions of the language.
 Thus, the language must be nonregular because it does not meet the conditions
 of the Pumping Lemma.
 
\end_layout

\begin_layout Section
Context Free Grammars
\begin_inset CommandInset label
LatexCommand label
name "sec:contextFreeGrammars"

\end_inset


\end_layout

\begin_layout Standard
A context free grammar is a notation for describing languages.
 It is more powerful than regular expressions and finite automata, but still
 cannot define all possible languages.
 A context free grammar is composed of variables which stand for a set of
 strings.
 These variables are defined in terms of each other.
 These rules for how variables should be composed are often called productions.
 Take for example the language L = {
\begin_inset Formula $0^{n}1$
\end_inset


\begin_inset Formula $^{n}$
\end_inset

 | 
\begin_inset Formula $n\geq1$
\end_inset

}.
 This is a familar language that we saw earlier in the examples on what
 is not a regular language.
 A context free grammar (CFG) for 
\begin_inset Formula $L$
\end_inset

 can be defined as 
\begin_inset Formula $S\rightarrow01$
\end_inset

, 
\begin_inset Formula $S\rightarrow0S1$
\end_inset

.
 Here S is defined recursively such that there will always be an equal number
 of 0's and 1's.
\end_layout

\begin_layout Subsection
CFG Nomenclature
\begin_inset CommandInset label
LatexCommand label
name "subsec:CFGNomenclature"

\end_inset


\end_layout

\begin_layout Itemize
Terminals - symbols of the alphabet of the language being defined.
\end_layout

\begin_layout Itemize
Variables (Nonterminals) - A finite set of other symbols, each of which
 represents a language.
\end_layout

\begin_layout Itemize
Production (Rule) - a rule defining the relationships of terminals and nontermin
als.
 It has the form HEAD -> TAIL (BODY).
 The body is composed of terminals and nonterminals.
 Each production represents a language on its own and nontermials in the
 BODY represent languages on their own.
 Nonterminals are subsets of the parent language given by the head ( e.g.
 
\begin_inset Formula $A\rightarrow XY$
\end_inset

, where the concatenation of language 
\begin_inset Formula $X$
\end_inset

 and language
\begin_inset Formula $Y$
\end_inset

 forms the language 
\begin_inset Formula $A$
\end_inset

).
\end_layout

\begin_layout Itemize
Derivation - The process of repeatedly replacing symbols for terminals based
 on the productions of a CFG.
\end_layout

\begin_layout Itemize
Sentential form - the derived string.
\end_layout

\begin_layout Subsection
Conventional Usage of Context Free Grammars
\begin_inset CommandInset label
LatexCommand label
name "subsec:conventionalUsageOfContextFreeGrammars"

\end_inset


\end_layout

\begin_layout Standard
Captial letters at the beginning of the alphabet are typically used as variables
 (e.g A, B, C).
 Lowercase letters at the beginning of the alphabet are used as terminals
 (a, b, c).
 Capital letters at the end of the alphabet can be either terminals or variables
 (X, Y, Z).
 Lowercase letters at the end of the alphabet are strings containing terminals
 only (e.g.
 w, x, y, z).
 Greek letters are strings of terminals or variables (
\begin_inset Formula $\alpha,$
\end_inset


\begin_inset Formula $\beta,\gamma)$
\end_inset

.
 A star (*) indicates 0 or more steps are necessary to obtain a specified
 derivation.
 A variable followed by the epsilon symbol effectively causes the variable
 to disappear in the derivation process.
 A 
\begin_inset Formula $\Rightarrow_{lm}$
\end_inset

 indicates the sentenial form is as specified after one setp of the left
 most derivation.
 A 
\begin_inset Formula $\Rightarrow*_{lm}$
\end_inset

 indicates 0 or more leftmost derivations are required to obtain the specified
 sentential form.
 Corresponding symbols for the rightmost derivations exist as well.
\end_layout

\begin_layout Subsection
Context-Free Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:contextFreeLanguages"

\end_inset


\end_layout

\begin_layout Standard
A language that is defined by some CFG is called a context-free language.
 Intuitively, a context free language is a language that can count to infinite
 elements but not three.
 An example of a non-context freem language is 
\begin_inset Formula $L=\{0^{n}1^{n}2^{n}|n\geq1\}$
\end_inset

.
\end_layout

\begin_layout Subsection
Leftmost and Rightmost Derivations
\begin_inset CommandInset label
LatexCommand label
name "subsec:leftMostRightMostDerivations"

\end_inset


\end_layout

\begin_layout Standard
Leftmost derivations process a string's variables one-at-the-time from left
 to right.
 Similarly, the rightmost derivation is processed from right to left.
\end_layout

\begin_layout Subsection
Normal Forms for CFG's
\begin_inset CommandInset label
LatexCommand label
name "subsec:normalFormsForCFG"

\end_inset


\end_layout

\begin_layout Standard
Poorly designed context free grammars may have rules that are never used
 in the derivation of strings.
 This is similiar to a DFA that has unreachable states.
 CFG's may also have redundant productions that may be combined.
 
\end_layout

\begin_layout Subsubsection
Eliminating Useless Variables from CFG's
\begin_inset CommandInset label
LatexCommand label
name "subsec:eliminatingUselessVariables"

\end_inset


\end_layout

\begin_layout Standard
If a CFG's production never derives a terminal string, then it is useless.
 In order to discover useless productions and eliminate them we must have
 an inductive algorithm which determines how the derivation proceeds by
 marking the variables that do derive terminals.
 The variables not contained in the set discovered by the algorithm can
 then be eliminated.
 The algorithm follows: For the basis step find a productions that derive
 a string of terminals.
 If there is a production that derives a string of terminals and variables
 whose variables have productions that yields strings of terminals alone,
 then this production derives terminal strings.
 For example if there is a production 
\begin_inset Formula $A\rightarrow w$
\end_inset

, where 
\begin_inset Formula $w$
\end_inset

 consists only of terminals, then this qualifies as our basis.
 If we then have a prodcution 
\begin_inset Formula $A\rightarrow\alpha$
\end_inset

 who derives a string of variables and terminals than theis may qualify
 for our inductive step.
 Additionally, we may have unreachable variables in the grammar.
 Variables that are unreachable can be eliminated from the grammar by an
 induction on the variables that are reachable from the start symbol 
\begin_inset Formula $S$
\end_inset

 and the productions that envolve the symbols of those that were discovered.
 Variables not discovered can then be eliminated.
\end_layout

\begin_layout Subsubsection
Elimininating Epilson Productions
\begin_inset CommandInset label
LatexCommand label
name "subsec:elimininatingEpilsonProduction"

\end_inset


\end_layout

\begin_layout Standard
Epsilon prodcutions are of the form 
\begin_inset Formula $A\rightarrow\epsilon$
\end_inset

.
 These productions can be eliminated from the grammar, however in doing
 so the grammar loses the ability to represent the empty string.
 To eliminate epsilon productions we need to discover the nullable symbols
 of the grammar.
 A nullable symbol is a symbol that eventually derives the empty string
 (i.e.
 A
\begin_inset Formula $\Rightarrow^{*}\epsilon$
\end_inset

 ).
 The following inductive argument can be used to discover nullable symbols.
 The basis is obviously if a production directly derives epsilon as in 
\begin_inset Formula $A\rightarrow\epsilon$
\end_inset

, then it is a nullable symbol.
 The induction then becomes, if there is a production 
\begin_inset Formula $A\rightarrow\alpha$
\end_inset

, in which all the symbols of 
\begin_inset Formula $\alpha$
\end_inset

eventulay derive epsilon then the production is nullable.
 
\end_layout

\begin_layout Subsubsection
Eliminating Unit Productions
\begin_inset CommandInset label
LatexCommand label
name "subsec:eliminatingUnitProductions"

\end_inset


\end_layout

\begin_layout Standard
Unit productions are productions whose body consist of a single variable.
 The key idea is that if a variable 
\begin_inset Formula $A$
\end_inset

 eventually derives a variable single variable 
\begin_inset Formula $B$
\end_inset

 by a series of unit productions, and 
\begin_inset Formula $B$
\end_inset

derives the production 
\begin_inset Formula $B\rightarrow\alpha$
\end_inset

, then we can rewite 
\begin_inset Formula $A$
\end_inset

 as the production 
\begin_inset Formula $A\rightarrow\alpha$
\end_inset

 and drop all the intermediate unit productions.
 The algorithm to discover unit productions is as follows: Find all pairs
 of variables 
\begin_inset Formula $(A,B)$
\end_inset

 such that 
\begin_inset Formula $A\Rightarrow^{*}B$
\end_inset

 by a sequence of unit production only.
 The induction has the basis 
\begin_inset Formula $(A,A)$
\end_inset

 and the IH if we have found 
\begin_inset Formula $(A,B)$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 derives 
\begin_inset Formula $C$
\end_inset

, then 
\begin_inset Formula $A$
\end_inset

 derives 
\begin_inset Formula $C$
\end_inset

 and so they form the pair 
\begin_inset Formula $(A,C).$
\end_inset


\end_layout

\begin_layout Subsubsection
Representing Grammars in Chomsky Normal Form (CNF)
\begin_inset CommandInset label
LatexCommand label
name "subsec:representingGrammarsInChomskyNormalForm"

\end_inset


\end_layout

\begin_layout Standard
Context free grammars in Chomsky Normal Formal are restricted to productions
 of two types:
\end_layout

\begin_layout Itemize
Productions with two variables (
\begin_inset Formula $A\rightarrow BC).$
\end_inset


\end_layout

\begin_layout Itemize
Productions with a single terminal (
\begin_inset Formula $A\rightarrow a).$
\end_inset


\end_layout

\begin_layout Standard
Theorem: If a language 
\begin_inset Formula $L$
\end_inset

 is a context free language, then the language with all epsilon productions
 eliminated has a context free grammar in Chomsky Normal Form.
 Forming the CFG such that it is in CNF can be carried out by cleaning up
 the grammar as descibed in the subsections
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:elimininatingEpilsonProduction"

\end_inset

,
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:eliminatingUnitProductions"

\end_inset

, and 
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:eliminatingUselessVariables"

\end_inset

.
 
\end_layout

\begin_layout Section
Pushdown Automata
\begin_inset CommandInset label
LatexCommand label
name "sec:Pushdown-Automata"

\end_inset


\end_layout

\begin_layout Standard
A pushdown automata(PDA) is equivalent in power to a context free grammar
 (CFG) in that any language defined in terms of a CFG can be equally defined
 in terms of a PDA.
 Traditionally, when speaking about PDA's we mean the nondeterministic type
 (NPDA).
 NPDA's are more powerful than their deterministic counterparts.
 Intuitively speaking a PDA is like an 
\begin_inset Formula $\epsilon-$
\end_inset

NFA with the additional power of manipulating a stack.
 The computation of the PDA is controlled by the state of its 
\begin_inset Formula $\epsilon-$
\end_inset

NFA, the input symbol to be processed, and finally the symbol on top of
 its stack.
 Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:pushdownAutomata"

\end_inset

.
 In addition to transition to a new state, the PDA may push or pop symbols
 off of the stack.
 PDA's are typically described by the following components 
\begin_inset Formula $Q$
\end_inset

 a finite set of states, 
\begin_inset Formula $\Sigma$
\end_inset

 an input alphabet, 
\begin_inset Formula $\Gamma$
\end_inset

 a stack alphabet, 
\begin_inset Formula $\delta$
\end_inset

 a transistion function, 
\begin_inset Formula $q_{0}$
\end_inset

 a start state,
\begin_inset Formula $z_{0}$
\end_inset

 a stack start symbol, and a set of final states 
\begin_inset Formula $F\subseteq Q$
\end_inset

 .
 The transition function 
\begin_inset Formula $\delta$
\end_inset

 is parameterized by three components: a state in 
\begin_inset Formula $Q$
\end_inset

, an input symbol in 
\begin_inset Formula $\Sigma$
\end_inset

, and a stack symbol in 
\begin_inset Formula $\Gamma$
\end_inset

 (e.g.
 
\begin_inset Formula $\delta(q_{0},a,Z)$
\end_inset

).
 The 
\begin_inset Formula $\delta$
\end_inset

 of given parameters yields a set of tuples containing a state to transition
 to and a symbol to manipulate the stack 
\begin_inset Formula $\left(p,a\right)$
\end_inset

.
 Here 
\begin_inset Formula $p$
\end_inset

 represents the next state and 
\begin_inset Formula $a$
\end_inset

is a string of stack symbols possibly empty.
 
\end_layout

\begin_layout Subsection
Conventional Usage of Pushdown Automata
\begin_inset CommandInset label
LatexCommand label
name "subsec:conventionalUsageOfPDA"

\end_inset


\end_layout

\begin_layout Standard
Lowercase letters at the beginning of the alphabet (e.g.
 a, b, c, and 
\begin_inset Formula $\epsilon$
\end_inset

) are used as input symbols.
 Capital letters at the end of the alphabet are used as stack symbols (e.g.
 X, Y, and Z).
 Lowercase letters at the end of the alphabet (e.g.
 w,x,y, and z) are used as strings of input symbols.
 Greek letters are used as strings of stack symbols (e.g.
 
\begin_inset Formula $\alpha,\beta$
\end_inset

 and 
\begin_inset Formula $\gamma)$
\end_inset

 are strings of stack symbols.
 An example of a PDA modeling the language 
\begin_inset Formula $L=\{0^{n}1^{n}|n\geq1\}$
\end_inset

 is given in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:pdaExample"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Instantaneous Descriptions and the Goes-To Relation
\begin_inset CommandInset label
LatexCommand label
name "subsec:instantaneousDescriptionsAndGoesToRelation"

\end_inset


\end_layout

\begin_layout Standard
An instantaneous description(ID) of a PDA is like a snapshot of a PDA as
 it computes.
 Each sucessesive step in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:pdaExample"

\end_inset

 has a corresponding instantaeous description triple describing the current
 state 
\begin_inset Formula $q$
\end_inset

, the remaining input 
\begin_inset Formula $w,$
\end_inset

and the contents of the stack 
\begin_inset Formula $a$
\end_inset

.
 The vertical dash symbol, 
\begin_inset Formula $\vdash$
\end_inset

, represents the Goes-To relation.
 The relation means that for a specified ID I a tranistion to ID J is possible
 in one step.
 For example if the transition function 
\begin_inset Formula $\delta(q,a,X)$
\end_inset

 yields 
\begin_inset Formula $\left(p,\beta\right)$
\end_inset

 the we may specify the Goes-To relation as 
\begin_inset Formula $(q,aw,Xa)\vdash(p,w,\beta\alpha)$
\end_inset

.
 Similiarly, the 
\begin_inset Formula $\vdash^{*}$
\end_inset

 means the transition occurs in zero or more steps.
\end_layout

\begin_layout Subsection
PDA Language Descriptions
\begin_inset CommandInset label
LatexCommand label
name "subsec:PDALanguageDescriptions"

\end_inset


\end_layout

\begin_layout Standard
The languages of PDA's are defined by 
\begin_inset Formula $L(P)$
\end_inset

 for the set of strings 
\begin_inset Formula $w$
\end_inset

 such that for the ID 
\begin_inset Formula $(q_{0},w,Z)$
\end_inset


\begin_inset Formula $\vdash^{*}$
\end_inset


\begin_inset Formula $(f,\epsilon,\alpha)$
\end_inset

 for the final state 
\begin_inset Formula $f$
\end_inset

 and the stack string 
\begin_inset Formula $a$
\end_inset

.
 This is the set of strings 
\begin_inset Formula $w$
\end_inset

 that are consumed by the PDA such that only the empy string, 
\begin_inset Formula $\epsilon,$
\end_inset

 is left in the final state.
 The notation 
\begin_inset Formula $N(P)$
\end_inset

 for a given PDA 
\begin_inset Formula $P$
\end_inset

 describes the PDA's language when the stack becomes empty.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/pushdownAutomata.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pushdownAutomata"

\end_inset

 Three elements control how a PDA will compute: the input, the state, and
 the stack
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/pdaExample.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pdaExample"

\end_inset

The computation shows the evolution of the PDA's stack, input and state
 as the string is processed.
 The initial starting state is shown on the left and the final accepting
 state is shown on the right.
 The following transitions define the behavior: 
\begin_inset Formula $\delta(q,0,Z)=\{(q,XZ)\}$
\end_inset

, 
\begin_inset Formula $\delta(q,0,X)=\{(q,XX)\}$
\end_inset

, 
\begin_inset Formula $\delta(q,1,X)=\{(p,\epsilon)\}$
\end_inset

, 
\begin_inset Formula $\delta(p,1,X)=\{(p,\epsilon)\}$
\end_inset

, 
\begin_inset Formula $\delta(p,\epsilon,Z)=\{(f,Z)\}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Equivalence of CFG's and PDA's
\begin_inset CommandInset label
LatexCommand label
name "sec:equivalenceCFGPDA"

\end_inset


\end_layout

\begin_layout Subsection
Converting CFG's 
\begin_inset Formula $\Rightarrow$
\end_inset

 PDA's
\begin_inset CommandInset label
LatexCommand label
name "subsec:Converting-CFG's-"

\end_inset


\end_layout

\begin_layout Standard
For some grammar 
\begin_inset Formula $G$
\end_inset

, let the language 
\begin_inset Formula $L=L(G).$
\end_inset

 We construct the PDA P such that upon emptying the stack we obtain a string
 in the language 
\begin_inset Formula $L$
\end_inset

 (i.e.
 
\begin_inset Formula $N(P)=L$
\end_inset

).
 P has one state 
\begin_inset Formula $q.$
\end_inset

 The terminals of the grammar G become the input symbols 
\begin_inset Formula $\Sigma$
\end_inset

 of the PDA 
\begin_inset Formula $P$
\end_inset

.
 The variables and terminals of G make up the stack symbols 
\begin_inset Formula $\Gamma$
\end_inset

 of the 
\begin_inset Formula $P$
\end_inset

.
 The start symbol of 
\begin_inset Formula $G$
\end_inset

 becomes the start symbol of 
\begin_inset Formula $P.$
\end_inset

 Intutitively, we must model the left sentential form of a grammar with
 the PDA.
 If the stack of the PDA 
\begin_inset Formula $P$
\end_inset

 is 
\begin_inset Formula $a,$
\end_inset

 and 
\begin_inset Formula $P$
\end_inset

has so far consumed 
\begin_inset Formula $x$
\end_inset

from its input, then 
\begin_inset Formula $P$
\end_inset

 represents the left-sentential form 
\begin_inset Formula $xa$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Creating the Transition Function
\begin_inset CommandInset label
LatexCommand label
name "subsec:creatingTheTransitionFunction"

\end_inset


\end_layout

\begin_layout Standard
There are two kinds of rules in the transition function of P, depending
 on whether a terminal or variable of G is at the top of P’s stack.
 The 
\emph on
type-1
\emph default
 rules handle the case where “a” is the terminal on top of P’s stack (
\begin_inset Formula $\delta(q,a,a)=(q,\epsilon))$
\end_inset

.
 There better be an “a” as the next input symbol, or P has guessed wrongly
 about the leftmost derivation of the input as it actually exists.
 In effect, we “cancel” the “a” on the stack against the “a” on the input.
 The left-sentential form represented does not change.
 We have now consumed one more symbol, “a”, from the input so that becomes
 part of the left-sentiantial form.
 But the “a” that was on the stack is removed, so it no longer participates
 in the left-sentential form.
 The 
\emph on
type-2
\emph default
 rules handle a variable, say 
\begin_inset Formula $A$
\end_inset

, on the top of the stack (
\begin_inset Formula $\delta(q,\epsilon,A)=(q,a))$
\end_inset

.
 We need to expand that variable by the body of one of its productions,
 and thus move to the next left-sentential form.
 Of course we’re only guessing.
 We have to allow any of 
\begin_inset Formula $A's$
\end_inset

 productions to be used.
 If 
\begin_inset Formula $A\rightarrow a$
\end_inset

 is one of these productions, then a choice for 
\begin_inset Formula $P$
\end_inset

, using epsilon input, and with 
\begin_inset Formula $A$
\end_inset

 on top of the stack, is to replace the 
\begin_inset Formula $A$
\end_inset

 by 
\begin_inset Formula $a$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Proof of Equivalence between CFG and PDA
\begin_inset CommandInset label
LatexCommand label
name "subsec:proofEquivalenceCFGPDA"

\end_inset


\end_layout

\begin_layout Standard
In order to prove equivalence between the two representations we need to
 prove that for all 
\begin_inset Formula $x,$
\end_inset


\begin_inset Formula $(q,wx,S)\vdash^{*}(q,x,\alpha)\leftrightarrow S\Rightarrow_{lm}^{*}w\alpha$
\end_inset

.
 That is, for all x the instantaneous decription 
\begin_inset Formula $(q,wx,S)$
\end_inset

 goes to 
\begin_inset Formula $(q,x,\alpha)$
\end_inset

 in some number of steps of the PDA if and only if the CFG's leftmost derivation
 yields 
\begin_inset Formula $w\alpha$
\end_inset

.
 It is important to note that we allow for the suffix 
\begin_inset Formula $x$
\end_inset

in the string 
\begin_inset Formula $wx$
\end_inset

.
 The string 
\begin_inset Formula $x$
\end_inset

 has no effect on the process of consuming 
\begin_inset Formula $w$
\end_inset

 and so if the that statement is true for one 
\begin_inset Formula $x$
\end_inset

it is true for all 
\begin_inset Formula $x.$
\end_inset

 The proof follow starting from the only if direction 
\begin_inset Formula $(\rightarrow)$
\end_inset

.
 That is, if P transitions 
\begin_inset Formula $(q,wx,S)$
\end_inset

 goes to 
\begin_inset Formula $(q,x,\alpha)$
\end_inset

, then 
\begin_inset Formula $S\Rightarrow_{lm}^{*}w\alpha$
\end_inset

.
 This will be an inductive proof where the base case is 0 steps have taken
 place and 
\begin_inset Formula $w$
\end_inset

 is 
\begin_inset Formula $\epsilon$
\end_inset

 and 
\begin_inset Formula $\alpha$
\end_inset

is 
\begin_inset Formula $S$
\end_inset

.
 The truth of the base case becomes trivial because 
\begin_inset Formula $S$
\end_inset

 is 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $w\alpha$
\end_inset

 is just 
\begin_inset Formula $\alpha$
\end_inset

 because 
\begin_inset Formula $\epsilon$
\end_inset

 serves as the identity of concatenation.
 Surely then, 
\begin_inset Formula $S$
\end_inset

 derives itself.
 Now we must consider the next 
\begin_inset Formula $n$
\end_inset

 steps of the proof, and assume an inductive hypothesis for the sequence
 of 
\begin_inset Formula $n-1$
\end_inset

 steps.
 For the 
\begin_inset Formula $n^{th}$
\end_inset

 step two cases can occur.
 A type-1 rule is used, or a type 2 rule is used.
 We will consider both case in turn.
 The descriptions of these rules are described in the previous subsection.
 For the use of a 
\emph on
type-1 
\emph default
rule in the 
\begin_inset Formula $n^{th}$
\end_inset

 step, the ID's for the 0 through 
\begin_inset Formula $n-1$
\end_inset

 steps must be 
\begin_inset Formula $(q,yax,S)\vdash^{*}(q,ax,a\alpha)\vdash(q,x,\alpha)$
\end_inset

, where 
\begin_inset Formula $ya=w$
\end_inset

.
 That is, the prefix of the string 
\begin_inset Formula $x$
\end_inset

must end with the symbol 
\begin_inset Formula $a$
\end_inset

 with the 
\begin_inset Formula $a$
\end_inset

 symbol on top of the stack followed by 
\begin_inset Formula $\alpha$
\end_inset

, and in the previous 
\begin_inset Formula $n-1$
\end_inset

 steps the string 
\begin_inset Formula $y$
\end_inset

 is consumed by the PDA, and in the 
\begin_inset Formula $n^{th}$
\end_inset

 step the PDA consumes the input symbol 
\begin_inset Formula $a$
\end_inset

 and removes it from the stack.
 By the inductive hypothesis applied to the 
\begin_inset Formula $n-1$
\end_inset

 steps, we can conlude that there is a left most derivation from 
\begin_inset Formula $S$
\end_inset

 to 
\begin_inset Formula $ya\alpha$
\end_inset

 because y was consumed and thus equivalent to 
\begin_inset Formula $\epsilon$
\end_inset

and 
\begin_inset Formula $a\alpha$
\end_inset

 is on the stack.
 The symbol 
\begin_inset Formula $a$
\end_inset

is then consumed from the input and popped from stack taking us back to
 the base case because 
\begin_inset Formula $ya=w$
\end_inset

.
 For the use of a 
\emph on
type-2 
\emph default
rule in the 
\begin_inset Formula $n^{th}$
\end_inset

 step, the step sequence must be 
\begin_inset Formula $(q,wx,S)\vdash^{*}(q,x,A\beta)\vdash(q,x,\gamma\beta)$
\end_inset

 where 
\begin_inset Formula $A\rightarrow\gamma$
\end_inset

 is a production in the grammar and 
\begin_inset Formula $\alpha=\gamma\beta$
\end_inset

.
 In this case, we have a variable 
\begin_inset Formula $A$
\end_inset

 on top of the stack followed by the stack string 
\begin_inset Formula $\beta$
\end_inset

.
 In the 
\begin_inset Formula $n^{th}$
\end_inset

 step no input is consumed but the variable 
\begin_inset Formula $A$
\end_inset

 is replaced by the stack string 
\begin_inset Formula $\gamma$
\end_inset

.
 By the inductive hypothesis we obtain 
\begin_inset Formula $S\Rightarrow_{lm}^{*}wA\beta$
\end_inset

 after the first 
\begin_inset Formula $n-1$
\end_inset

 steps.
 Because 
\begin_inset Formula $A$
\end_inset

 is the leftmost variable in the derivation it is replaced by 
\begin_inset Formula $\gamma$
\end_inset

.
 We then have 
\begin_inset Formula $S\Rightarrow_{lm}^{*}w\gamma\beta=w\alpha$
\end_inset

 returning us to our base case, thus proving the only if direction of the
 proof.
 Next, we prove the if direction (
\begin_inset Formula $\leftarrow)$
\end_inset

.
 We now must prove 
\begin_inset Formula $S\Rightarrow_{lm}^{*}w\alpha\rightarrow(q,wx,S)\vdash^{*}(q,x,\alpha)$
\end_inset

 for all 
\begin_inset Formula $x$
\end_inset

 
\begin_inset Formula $\ldots$
\end_inset

[ommited]
\end_layout

\begin_layout Subsection
Converting PDA's 
\begin_inset Formula $\Rightarrow$
\end_inset

 CFG's
\begin_inset CommandInset label
LatexCommand label
name "subsec:convertingPDA2CFG"

\end_inset


\end_layout

\begin_layout Standard
In this section we obtain the grammar 
\begin_inset Formula $G$
\end_inset

 from a PDA 
\begin_inset Formula $P$
\end_inset

.
 We assume that the language 
\begin_inset Formula $L$
\end_inset

 is accepted by the PDA upon emptying its stack, more formally 
\begin_inset Formula $L=N(P).$
\end_inset

 Intuitively, we should assign variables labled as 
\begin_inset Formula $pXq$
\end_inset

 to the grammar 
\begin_inset Formula $G$
\end_inset

 for the transitions from state 
\begin_inset Formula $p$
\end_inset

to state 
\begin_inset Formula $q$
\end_inset

when popping the symbol 
\begin_inset Formula $X$
\end_inset

 from the PDA's stack.
 Upon popping the 
\begin_inset Formula $X$
\end_inset

 from the stack it may grow, but the stack size will not shrink below the
 size when 
\begin_inset Formula $X$
\end_inset

 was popped off the stack until the last step in processing is taken.
\end_layout

\begin_layout Subsubsection
Constructing Variables of the CFG
\begin_inset CommandInset label
LatexCommand label
name "subsec:constructingVariablesOfCFG"

\end_inset


\end_layout

\begin_layout Standard
The variables of 
\begin_inset Formula $G$
\end_inset

 are correspond to labels such as 
\begin_inset Formula $pXq$
\end_inset

 which can be viewed as a single symbol modeling the transition from p to
 q with X on the stack in which the input is consumed and generates all
 and only the strings 
\begin_inset Formula $w$
\end_inset

 until 
\begin_inset Formula $\left(p,w,X\right)\vdash^{*}(q,\epsilon,\epsilon)$
\end_inset

.
 Note that since the initial ID shows nothing below 
\begin_inset Formula $X$
\end_inset

 on the stack, we know that 
\begin_inset Formula $X$
\end_inset

 can’t be popped until the last step, since PDA P cannot make any moves
 when its stack is empty.In addition to the aforementioned variable a start
 symbol 
\begin_inset Formula $S$
\end_inset

 is needed.
\end_layout

\begin_layout Subsubsection
Constructing Productions of the CFG
\begin_inset CommandInset label
LatexCommand label
name "subsec:constructingProductionsOfCFG"

\end_inset


\end_layout

\begin_layout Standard
Intuitively, the productions or rules of the grammar represent steps of
 the PDA.
 Each rule for the example rule 
\begin_inset Formula $pXq$
\end_inset

 is sourced from the PDA in state 
\begin_inset Formula $p$
\end_inset

with the stack symbol 
\begin_inset Formula $X$
\end_inset

.
 In the easiest case we have the following for the PDA's transition function.
 
\begin_inset Formula $\delta(p,a,X)$
\end_inset

 yields 
\begin_inset Formula $(p,\epsilon)$
\end_inset

.
 Here 
\begin_inset Formula $a$
\end_inset

 denotes either a input symbol or 
\begin_inset Formula $\epsilon$
\end_inset

.
 The grammar in this case can model the PDA's behavior by popping 
\begin_inset Formula $X$
\end_inset

and not replacing it with any other symbol 
\begin_inset Formula $(pXq\rightarrow a)$
\end_inset

.
 The next simplest case simplest case involves modeling transition between
 productions.
 Transitivy is modeled by introducing an intermediate state 
\begin_inset Formula $r$
\end_inset

and a variable 
\begin_inset Formula $Y$
\end_inset

.
 The transition function in this case would look like 
\begin_inset Formula $\delta(p,a,X)$
\end_inset

 yields 
\begin_inset Formula $(r,Y)$
\end_inset

.
 The corresponding production would then be 
\begin_inset Formula $pXq\rightarrow arYq$
\end_inset

.
 This allows us to erase X and transition from 
\begin_inset Formula $p$
\end_inset

 to 
\begin_inset Formula $q$
\end_inset

 by way of 
\begin_inset Formula $r$
\end_inset

 while reading 
\begin_inset Formula $a$
\end_inset

and pushing 
\begin_inset Formula $Y$
\end_inset

 onto the stack.
 The final simplest case we will consider is 
\begin_inset Formula $\delta(p,a,X)$
\end_inset

 yields 
\begin_inset Formula $(r,YZ)$
\end_inset

 for some state 
\begin_inset Formula $r$
\end_inset

 and some symbols 
\begin_inset Formula $Y$
\end_inset

and 
\begin_inset Formula $Z$
\end_inset

.
 Here 
\begin_inset Formula $X$
\end_inset

 is replaced by 
\begin_inset Formula $YZ$
\end_inset

.
 In order for 
\begin_inset Formula $X$
\end_inset

 to be erased, there must be some input string u that has the net effect
 of erasing 
\begin_inset Formula $Y$
\end_inset

.
 And 
\begin_inset Formula $u$
\end_inset

 must take the PDA from state 
\begin_inset Formula $r$
\end_inset

 to some state 
\begin_inset Formula $s$
\end_inset

, which we don’t know.
 As a result, we’re going to have to have one production for each state
 
\begin_inset Formula $s$
\end_inset

.
 But after reaching state 
\begin_inset Formula $s$
\end_inset

, we must have some additional input 
\begin_inset Formula $v$
\end_inset

 that takes the PDA from state 
\begin_inset Formula $s$
\end_inset

 to state 
\begin_inset Formula $q$
\end_inset

, while popping the 
\begin_inset Formula $Z$
\end_inset

 from the stack.
 The net effect is that
\begin_inset Formula $auv$
\end_inset

 pops 
\begin_inset Formula $X$
\end_inset

 from the stack while going from state 
\begin_inset Formula $p$
\end_inset

 to 
\begin_inset Formula $q.$
\end_inset

 The general case for creating productions to model the PDA follows.
 Suppose 
\begin_inset Formula $\delta(p,a,X)$
\end_inset

 yields 
\begin_inset Formula $(r,Y_{1},\ldots Y_{k})$
\end_inset

 for some state 
\begin_inset Formula $r$
\end_inset

 and 
\begin_inset Formula $k\geq3.$
\end_inset

 Then in the grammar generate the set of productions 
\begin_inset Formula $pXq\rightarrow arY_{1}s_{1}s_{1}Y_{2}s_{2}\ldots s_{k-2}Y_{k-1}s_{k-1}s_{k-1}Y_{k}q$
\end_inset

.
 This models the case in which 
\begin_inset Formula $X$
\end_inset

 is replaced by three or more symbols transitioning from 
\begin_inset Formula $p$
\end_inset

 to 
\begin_inset Formula $q.$
\end_inset


\end_layout

\begin_layout Section
Pumping Lemma for Context Free Languages
\begin_inset CommandInset label
LatexCommand label
name "sec:pumpingLemmaForContextFreeLanguages"

\end_inset


\end_layout

\begin_layout Standard
Recall the concepts for the pumping lemma on regular languages outlined
 in Section
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:pumpingLemmaRegularLanguages"

\end_inset

.
 The pumping lemma for regular languages relied on a cycle early on in a
 sufficiently long string 
\begin_inset Formula $w$
\end_inset

 in order 
\begin_inset Quotes eld
\end_inset

pump
\begin_inset Quotes erd
\end_inset

 an the string an arbitrary number of times, thus producing a infinite number
 of strings in the language.
 Similiarly, the pumping lemma for context free languages models this idea,
 but requires two cycles along the string's path in tandem.
 
\end_layout

\begin_layout Subsection
Formal Specification of the CFL Pumping Lemma
\begin_inset CommandInset label
LatexCommand label
name "subsec:formalSpecificationOfContextFreeLanguages"

\end_inset


\end_layout

\begin_layout Standard
For every context free language 
\begin_inset Formula $L$
\end_inset

, there is an integer 
\begin_inset Formula $n$
\end_inset

, such that for every string 
\begin_inset Formula $z$
\end_inset

 in 
\begin_inset Formula $L$
\end_inset

 of length 
\begin_inset Formula $\geq n$
\end_inset

 there exists 
\begin_inset Formula $z=uvwxy$
\end_inset

 such that the following conditions hold:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $|vwx|\leq n.$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $|vx|>0.$
\end_inset


\end_layout

\begin_layout Enumerate
For all 
\begin_inset Formula $i\geq0$
\end_inset

, 
\begin_inset Formula $uv^{i}wx^{i}y$
\end_inset

 is in 
\begin_inset Formula $L.$
\end_inset


\end_layout

\begin_layout Standard
If a language in question does not have these properties, then it is not
 a context free language.
\end_layout

\begin_layout Section
Properties of Context Free Languages
\begin_inset CommandInset label
LatexCommand label
name "sec:propertiesOfContextFreeLanguages"

\end_inset


\end_layout

\begin_layout Subsection
Decision Properties of Context Free Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:decisionPropertiesOfContextFreeLanguages"

\end_inset


\end_layout

\begin_layout Standard
Like regular languages we can determine many decision properties about context
 free languages including whether a string in the particular CFL, whether
 a CFL contains any strings at all, and if the CFL contains an infinite
 number of strings.
 Unfortunately,we cannot decide whether two CFL's are equivalent, or whether
 they are disjoint.
\end_layout

\begin_layout Subsubsection
Membership Test for CFL's
\begin_inset CommandInset label
LatexCommand label
name "subsec:membershipTestForCFL"

\end_inset


\end_layout

\begin_layout Standard
The membership test is used to determine whether a given string 
\begin_inset Formula $w$
\end_inset

 is the language of the grammar 
\begin_inset Formula $L(G).$
\end_inset

 We need the grammar to be in Chomsky Normal Form, so if it isn't then convert
 it to this form as described in subsection
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:representingGrammarsInChomskyNormalForm"

\end_inset

.
 Then use the CYK algorithm to determine the status of 
\begin_inset Formula $w.$
\end_inset

 The CYK algorithm uses Dynamic Programming to decide whether 
\begin_inset Formula $w$
\end_inset

 is in the language or not, so it may be useful to first review the section
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Dynamic-Programming"

\end_inset

 first in order to gain better understanding of CYK.
\end_layout

\begin_layout Subsubsection
The CYK ALgorithm
\end_layout

\begin_layout Standard
\align left
Let 
\begin_inset Formula $w=a_{0}\ldots a_{n}$
\end_inset

 be a string of length 
\begin_inset Formula $n$
\end_inset

where 
\begin_inset Formula $a_{i}$
\end_inset

 stores the symbol at the 
\begin_inset Formula $i^{th}$
\end_inset

 position.
 Construct a 
\begin_inset Formula $n$
\end_inset

 by 
\begin_inset Formula $n$
\end_inset

 triangular array.
 This can done efficiently by using an indexing function where upon a single-ind
exed array is mapped to an upper-triangular array.
 The following function 
\begin_inset Formula $k=j(j+1)/2+i$
\end_inset

 where 
\begin_inset Formula $k$
\end_inset

 represents the index into the array properly maps the elements of the array.
 This idea can be viewed in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:triangularArray"

\end_inset

.
 Additionaly, each entry of the array should be viewed as a set of variables
 of the grammar.
 The set 
\begin_inset Formula $X_{ij}$
\end_inset

 is stored in position 
\begin_inset Formula $(i,j)$
\end_inset

 of the array where 
\begin_inset Formula $i\leq j$
\end_inset

 and is inteded to be the set of variables that derive the substring of
 the input starting from position 
\begin_inset Formula $i$
\end_inset

 and ending at position 
\begin_inset Formula $j$
\end_inset

.
 An inductive argument is used to fill the table on the length of the input
 string derived .
 The length of the string can be computed as 
\begin_inset Formula $j-i+1$
\end_inset

.
 We start by computing the entries 
\begin_inset Formula $X_{i,i}$
\end_inset

, which is the set of variables that derive the string consisting of the
 symbol at 
\begin_inset Formula $a_{i}$
\end_inset

 .
 Next, we find the variables at 
\begin_inset Formula $X_{i,i+1}$
\end_inset

 each of which derive the string at 
\begin_inset Formula $a_{i,i+1}$
\end_inset

.
 Then, we move to the 
\begin_inset Formula $X_{i,i+2}$
\end_inset

 variables which are the sets of variables that derive the strings of length
 three, 
\begin_inset Formula $a_{i},$
\end_inset


\begin_inset Formula $a_{i+1},$
\end_inset


\begin_inset Formula $a_{i+2}$
\end_inset

 and so on .
 Finally, after we have computed the set 
\begin_inset Formula $X_{1,n}$
\end_inset

 which represents the entire input string , we can test whether the start
 symbol 
\begin_inset Formula $S$
\end_inset

 is contained in the set .
 If it is then the string is in the language, otherwise it is not.
 Formally, the basis 
\begin_inset Formula $X_{i,i}=\{A|A\Rightarrow^{*}a_{i}\}$
\end_inset

 where 
\begin_inset Formula $a_{i}$
\end_inset

 represents a single symbol in 
\begin_inset Formula $w$
\end_inset

.
 The induction is then 
\begin_inset Formula $X_{i,j}$
\end_inset

={A| there is a production 
\begin_inset Formula $A\rightarrow BC$
\end_inset

, and an integer 
\begin_inset Formula $k$
\end_inset

, with 
\begin_inset Formula $i\leq k<j$
\end_inset

, such that 
\begin_inset Formula $B$
\end_inset

 is in 
\begin_inset Formula $X_{i,k}$
\end_inset

 and 
\begin_inset Formula $C$
\end_inset

 is in 
\begin_inset Formula $X_{k+1,j}$
\end_inset

}.That is, for each 
\begin_inset Formula $k$
\end_inset

 between 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j-1$
\end_inset

 we look for some 
\begin_inset Formula $B$
\end_inset

 in 
\begin_inset Formula $X_{i,k}$
\end_inset

 and some 
\begin_inset Formula $C$
\end_inset

 in 
\begin_inset Formula $X_{k+1,j}$
\end_inset

 such that 
\begin_inset Formula $BC$
\end_inset

 is the body of an 
\begin_inset Formula $A$
\end_inset

 production.
 If for any 
\begin_inset Formula $k$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

, and 
\begin_inset Formula $C$
\end_inset

 we find such a production, we add 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $X_{i,j}$
\end_inset

.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="decimal" decimal_point="." valignment="top">
<column alignment="decimal" decimal_point="." valignment="top">
<column alignment="decimal" decimal_point="." valignment="top">
<column alignment="decimal" decimal_point="." valignment="top" width="0pt">
<row>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="decimal" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:triangularArray"

\end_inset

A single index array can be viewed as a triangular array by accessing it
 with a function mapping the rows and columns appropriately.
 The function 
\begin_inset Formula $k=j(j+1)/2+i$
\end_inset

 maps the index value 
\begin_inset Formula $k$
\end_inset

 to the appropriate 
\begin_inset Formula $i$
\end_inset

 and column 
\begin_inset Formula $j$
\end_inset

 where 
\begin_inset Formula $i\leq j$
\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Emptiness Test for CFL's
\begin_inset CommandInset label
LatexCommand label
name "subsec:emptinessTestForCFL"

\end_inset


\end_layout

\begin_layout Standard
The algorithim to test for an empty CFL uses the ideas we learned in subsection
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:eliminatingUselessVariables"

\end_inset

.
 We use these ideas of checking whether variables are useful in the derivation
 to determine if the start symbol 
\begin_inset Formula $S$
\end_inset

 is a useful symbol.
 If the start symbol does not derive anything, it is a useless variable,
 and we can state that the CFL is empty.
 
\end_layout

\begin_layout Subsubsection
Infiniteness Test for CFL's
\begin_inset CommandInset label
LatexCommand label
name "subsec:infinitenessTestCFL"

\end_inset


\end_layout

\begin_layout Standard
The test for infinteness in CFL mirrors the idea that was proposed in section
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:infinitenessTestRegularLanguages"

\end_inset

.
 Apply those priniciples with the pumping lemma for context free languages
 outlined in section
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:pumpingLemmaForContextFreeLanguages"

\end_inset

.
\end_layout

\begin_layout Subsection
Closure Properties of Context Free Languages
\begin_inset CommandInset label
LatexCommand label
name "subsec:closurePropertiesOfContextFreeLanguages"

\end_inset


\end_layout

\begin_layout Standard
For many of the same operations under which the class of regular languages
 are closed, the context-free languages are also closed.
 These include the regular-expression operations: union, concatenation,
 and closure.
 Also reversal, homomorphism and inverse homomorphism.
 But unlike the class of regular languages, the class of context-free languages
 is not closed under intersection or difference.
 
\end_layout

\begin_layout Subsubsection
Union for CFL's
\begin_inset CommandInset label
LatexCommand label
name "subsec:unionForCFL's"

\end_inset


\end_layout

\begin_layout Standard
//TODO
\end_layout

\begin_layout Subsubsection
Concatentation for CFL's
\begin_inset CommandInset label
LatexCommand label
name "subsec:concatentationForCFL's"

\end_inset


\end_layout

\begin_layout Standard
//TODO
\end_layout

\begin_layout Subsubsection
Kleene Closure for CFL's
\begin_inset CommandInset label
LatexCommand label
name "subsec:kleeneClosureForCFL's"

\end_inset


\end_layout

\begin_layout Standard
//TODO
\end_layout

\begin_layout Section
Countability
\begin_inset CommandInset label
LatexCommand label
name "sec:Countability"

\end_inset


\end_layout

\begin_layout Standard
It is important to understand that all computation can be encoded as integers.
 The ascii or if you like the UTF-8 table encodes english characters and
 algebraic numerals, which we can interpret as integers.
 This idea can be applied to all types of media.
 At the very root we may interpret all things as integers.
\end_layout

\begin_layout Subsection
Finite Sets
\end_layout

\begin_layout Standard
A finite set is a set that contains a finite number of elements.
 Refer to Section
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Sets"

\end_inset

.
 It may be useful to refresh your memory on this topic.
 The formal definition of a finite set is one for which it is impossible
 to find a one to one correspondence between the members of the set and
 a proper subset of the set.
 An example of a set is 
\begin_inset Formula $\{a,b,c\}.$
\end_inset


\end_layout

\begin_layout Subsection
Infinite Sets
\end_layout

\begin_layout Standard
An infinite set is a set for which there is a one to one correspondence
 between itself and a proper subset of itself.
 An example of a infinite set is the positive integers 
\begin_inset Formula $\{1,2,3,\ldots\}.$
\end_inset

 The one-to-one correspondence which validates this argument is the mapping
 of the positive integers with the even integers ( 
\begin_inset Formula $1\leftrightarrow2,2\leftrightarrow4,3\leftrightarrow6,\ldots)$
\end_inset

.
\end_layout

\begin_layout Subsection
Countable Sets
\end_layout

\begin_layout Standard
A countable set is a set with a one to one correspondence with the positive
 integers, thus all countable sets are infinite sets.
 As another example all integers 
\begin_inset Formula $\mathbb{Z}$
\end_inset

 form a countable set.
 0 is mapped to 1 and the negative integers are are mapped to the even numbers
 (
\begin_inset Formula $-i\leftrightarrow2i$
\end_inset

, for all 
\begin_inset Formula $i\geq1$
\end_inset

), while the positive integers are mapped to odd numbers
\begin_inset Formula $(i\leftrightarrow2i+1$
\end_inset

, for all 
\begin_inset Formula $i\geq1$
\end_inset

).
 The enumerated sequence then becomes 
\begin_inset Formula $0,-1,1,-2,2,-3,3,\ldots$
\end_inset

 Another example of an enumerable set is the binary strings, but there is
 a trick involved.
 The binary strings 
\begin_inset Formula $101,0101,00101$
\end_inset

 all coorespond to the integer value 5, so it seems imposible to form a
 coorespondence such that they become countable.
 The trick here is to prepend a 1 to the binary strings so that the strings
 can become distinguishable.
 The aforementioned strings become 
\begin_inset Formula $1101,10101,100101$
\end_inset

 as integers they are 13, 21, and 37.
\end_layout

\begin_layout Subsection
Countability of Languages Over the Binary Alphabet
\end_layout

\begin_layout Standard
The next bit is quite confusing (pun intended).
 The languages over the binary alphabet 
\begin_inset Formula $\Sigma=\{0,1\}$
\end_inset

 are not countable.
 To obtain a contradiction we use a technique that confounds a set formers
 specification.
 As with the other examples suppose we could encode languages over the binary
 alphabet so that we could speak about some specific enumerated language.
 For example, the 
\begin_inset Formula $i^{th}$
\end_inset

 language.
 Define the language 
\begin_inset Formula $L$
\end_inset

 = { w | w is the 
\begin_inset Formula $i^{th}$
\end_inset

 binary string and 
\begin_inset Formula $w$
\end_inset

 is not in the 
\begin_inset Formula $i^{th}$
\end_inset

 language}.
 Surely, the language 
\begin_inset Formula $L$
\end_inset

 is a language over the binary alphabet.
 Thus, 
\begin_inset Formula $L$
\end_inset

 is the 
\begin_inset Formula $j^{th}$
\end_inset

 language for some particular 
\begin_inset Formula $j.$
\end_inset

 Now let some binary string 
\begin_inset Formula $x$
\end_inset

be the 
\begin_inset Formula $j^{th}$
\end_inset

 string.
 Now consider substituting 
\begin_inset Formula $x$
\end_inset

for 
\begin_inset Formula $w$
\end_inset

 in the 
\begin_inset Formula $j^{th}$
\end_inset

 language 
\begin_inset Formula $L_{j}$
\end_inset

 = { 
\begin_inset Formula $x$
\end_inset

 | 
\begin_inset Formula $x$
\end_inset

is the 
\begin_inset Formula $j^{th}$
\end_inset

 binary string and 
\begin_inset Formula $x$
\end_inset

is not in the 
\begin_inset Formula $j^{th}$
\end_inset

 language}.
 For some arbitrary 
\begin_inset Formula $j^{th}$
\end_inset

 string 
\begin_inset Formula $x$
\end_inset

in the 
\begin_inset Formula $j^{th}$
\end_inset

 language 
\begin_inset Formula $L_{j}$
\end_inset

, if 
\begin_inset Formula $x$
\end_inset

is in 
\begin_inset Formula $L_{j}$
\end_inset

, then it cannot be by the definition of the language.
 If 
\begin_inset Formula $x$
\end_inset

is not in the language 
\begin_inset Formula $L_{j}$
\end_inset

, then 
\begin_inset Formula $x$
\end_inset

is in the language by the definition of the language.
 This makes for a very confusing situation.
 Remember, 
\begin_inset Formula $L$
\end_inset

 contains 
\begin_inset Formula $w$
\end_inset

 if and only if 
\begin_inset Formula $w$
\end_inset

 is not the language that correpsonds to the smae integer 
\begin_inset Formula $i$
\end_inset

 that 
\begin_inset Formula $w$
\end_inset

 corresponds to.
 We now have a contradiction and therefore we know that we know the languages
 over the binary strings are not countable.
 Graphically, this concept can be seen in the Diagonalization Method in
 Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:diagonalization"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="8">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Strings
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Languages
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ddots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:diagonalization"

\end_inset

 This diagram depicts a table used to describe whether strings are in a
 language or not.
 A binary integer 1 indicates that the string 
\begin_inset Formula $j^{th}$
\end_inset

 string is in the 
\begin_inset Formula $i^{th}$
\end_inset

 language, 0 indicates it is not in the language.
 Look at the diagonal in this table.
 If you were to first complement the main diagonal and then rotate it by
 45 degrees upon an axis created in the 
\begin_inset Formula $i^{th}$
\end_inset

 row and 
\begin_inset Formula $i^{th}$
\end_inset

 column, then it too would look like a language, but would always disagree
 with itself at the 
\begin_inset Formula $i^{th}$
\end_inset

 row and 
\begin_inset Formula $i^{th}$
\end_inset

 column.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Turing Machines
\begin_inset CommandInset label
LatexCommand label
name "sec:Turing-Machines"

\end_inset


\end_layout

\begin_layout Standard
Turing machines model the recursively enumerable languages which encompass
 the previously discussed languages.
 Sipser provides a good hierarchy to reference for how to regard which language
 classes are subsets of which.
 The diagram is provided in Figure
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:languageClassHierarchy"

\end_inset

.
 The purpose of Turing Machine theory is to provide a means of proving whether
 or not an algorithm exists for a given language.Reductions which will be
 explored in detail in later sections prove common questions are undecidable.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/LanguageClassHierarchy.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:languageClassHierarchy"

\end_inset

 The hierarchy of language classes.
 Turing-recognizable languages are sometimes called recursively enumerable
 languages.
 Decidable languages are sometimes called recursive languages.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
What is a Turing Machine?
\end_layout

\begin_layout Standard
A Turing Machine is a computational model composed of a tape and a head
 that reads and writes symbols onto the tape based on a transition function.
 The tape is infinite in both directions, and there is also some state that
 we track throughout computation.
 In one step of computation the Turing machine may read one symbol from
 the tape and modify it, and either move the head left or right one square.
\end_layout

\begin_layout Subsection
Turing Machine Notation
\end_layout

\begin_layout Standard
A Turing machine is made up of the following componenets.
\end_layout

\begin_layout Itemize
A finite set of states (
\begin_inset Formula $Q).$
\end_inset


\end_layout

\begin_layout Itemize
An input alphabet 
\begin_inset Formula $(\Sigma).$
\end_inset


\end_layout

\begin_layout Itemize
A tape alphabet 
\begin_inset Formula $(\Gamma,$
\end_inset

typically 
\begin_inset Formula $\Sigma\subseteq\Gamma)$
\end_inset

.
\end_layout

\begin_layout Itemize
A transition function (
\begin_inset Formula $\delta$
\end_inset

).
\end_layout

\begin_layout Itemize
A start state (
\begin_inset Formula $q_{0}\varepsilon Q)$
\end_inset

.
\end_layout

\begin_layout Itemize
A blank symbol (
\begin_inset Formula $\sqcup\subseteq\Gamma-\Sigma).$
\end_inset


\end_layout

\begin_layout Itemize
A set of final states (
\begin_inset Formula $F\subseteq Q)$
\end_inset

.
\end_layout

\begin_layout Standard
Conventionally, the lowercase letters at the beginning of the alphabet are
 input symbols (
\begin_inset Formula $a,b,c).$
\end_inset

 Upper case letters at the end of the alphabet represetn tape symbols 
\begin_inset Formula $(X,Y,Z)$
\end_inset

.
 Lowercase letters at the end of the alphabet represent input strings 
\begin_inset Formula $w,x,y,z$
\end_inset

.
 Greek symbols represent tape symbols 
\begin_inset Formula $(\alpha,\beta,\gamma)$
\end_inset

.
 The transition function 
\begin_inset Formula $\delta$
\end_inset

 takes two parameters a 
\begin_inset Formula $q_{i}\varepsilon Q$
\end_inset

 and a tape symbol in 
\begin_inset Formula $\Gamma$
\end_inset

.
 The transition function yields a triple of the form (state, tape symbol,
 direction).
 If for a given input a tranisiton is not defined then the Turing machine
 halts in the current state.
\end_layout

\begin_layout Subsection
Instantaneous Descriptions of Turing Machines
\end_layout

\begin_layout Standard
Instantaneous descriptions of Turing Machines are encoded as 
\begin_inset Formula $\alpha q_{i}\beta$
\end_inset

 where 
\begin_inset Formula $\alpha$
\end_inset

 represents the tape before the head of the Turing Machine until the leftmost
 blank and 
\begin_inset Formula $\beta$
\end_inset

 represents the tape after the head until the rightmost blank.
 The position of the head represented by a state symbol 
\begin_inset Formula $q_{i}$
\end_inset

 is just left of the tape string 
\begin_inset Formula $\beta$
\end_inset

.
 Further we use the symbol 
\begin_inset Formula $\vdash$
\end_inset

 to indicate 
\begin_inset Quotes eld
\end_inset

becomes in one move
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Formula $\vdash^{*}$
\end_inset

 as 
\begin_inset Quotes eld
\end_inset

becomes in zero or more moves.
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Subsection
Languages of a Turing Machine
\end_layout

\begin_layout Standard
A Turing machine's language is defined by its final states or a halting
 action.
 An example is 
\begin_inset Formula $L(M)$
\end_inset

 = { 
\begin_inset Formula $w$
\end_inset

 | 
\begin_inset Formula $q_{0}w\vdash^{*}I$
\end_inset

 , where I is an ID with a final state}.
 Halting can be described by 
\begin_inset Formula $H(M)$
\end_inset

 = {
\begin_inset Formula $w$
\end_inset

 | 
\begin_inset Formula $q_{0}w\vdash^{*}I$
\end_inset

, and there is no move possible from 
\begin_inset Formula $I\}.$
\end_inset


\end_layout

\begin_layout Subsection
Recursively Enumerable Languages vs.
 Recursive Languages
\end_layout

\begin_layout Standard
The class of languages accepted by a Turing Machine halting or entering
 an accepting state is called the Recursively Enumerable language class.
 Some textbooks also call this the Turing Recognizable language class.
 Turing Machines that accept by final state, and who are 
\emph on
guaranteed to halt
\emph default
 whether it accepts or not define the Recursive Languages class.
 In some textbooks this is called the Decidable Language class.
 
\end_layout

\begin_layout Subsection
Multitape Turing Machines
\end_layout

\begin_layout Standard
Multitape Turing Machines allow for a ordinary Turing Machine to have 
\begin_inset Formula $k$
\end_inset

 tapes for any fixed 
\begin_inset Formula $k.$
\end_inset

 The steps the Multitape Turing Machine makes are dependant on the symbols
 the head of each tape is pointing to and their corresponding states.
 Each tape has its own head and they move on their own tape without restricting
 each others movement.
 On each read of the tape a new symbol and state is assigned for each tape
 and head.
 Additionally, a head may choose to not move.
 This model is no more powerful than the traditional Turing Machine.
 One may simply expand the alphabet for a traditional Turing Machine to
 accomadate the number of tapes that it must simulate.
\end_layout

\begin_layout Subsection
Nondeterministic Turing Machines
\end_layout

\begin_layout Standard
Nondeterministic Turing Machines are granted multiple choices based on the
 state, direction, move triple.
 Once a choice is made, then the next state, new symbol and head direction
 are determined.
 As with the NFA's, DFA's, and PDA's, the nondeterministic Turing Machine
 accpets if any sequence of choices leads to an ID with and accepting state.
\end_layout

\begin_layout Subsection
Closure Properties of Recursive and Recursively Enumerable Languages
\end_layout

\begin_layout Standard
Recursive Languages and Recursively Enumerable Languages share the properites:
 union, concatenation, Kleene star, reversal, intersection, and inverse.
 Recursive languages have difference and complementation.
 Recursively Enumerable Languages have homomorphism.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/ClosurePropertiesRELandRL.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:closurePropertiesOfRELandRELanguages"

\end_inset

The closure properties of Recursive and Recursively Enumerable languages
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Union
\end_layout

\begin_layout Standard
Given two Turing machines 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 with languages 
\begin_inset Formula $L_{1}$
\end_inset

and 
\begin_inset Formula $L_{2}$
\end_inset

 respectively.
 The union of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 can be achieved by creating a third Turing Machine 
\begin_inset Formula $M$
\end_inset

.
 
\begin_inset Formula $M$
\end_inset

will be a two-tape Turing Machine.
 
\begin_inset Formula $M$
\end_inset

 will proceed by copying the tape of 
\begin_inset Formula $M_{1}$
\end_inset

 to its first tape, and 
\begin_inset Formula $M_{2}$
\end_inset

 to its second tape.
 Next, 
\begin_inset Formula $M$
\end_inset

 will simulate the input of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 independently.
 In the case of Recursive Languages (Decidable Languages), 
\begin_inset Formula $M$
\end_inset

will 
\emph on
accept
\emph default
 when either of its tapes enter an accepting state, and 
\emph on
reject
\emph default
 when 
\series bold
both
\series default
 of its tapes halt by not accepting.
 The case for Recursively Enumerable Languages is a bit more relaxed.
 In this case, 
\begin_inset Formula $M$
\end_inset

 need only to enter an accepting state on one of its tapes to accept.
 However, it may end up running forever and never providing an answer.
 
\end_layout

\begin_layout Subsubsection
Intersection
\end_layout

\begin_layout Standard
The idea behind intersection is quite similiar to union.
 Given two Turing machines 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 with languages 
\begin_inset Formula $L_{1}$
\end_inset

and 
\begin_inset Formula $L_{2}$
\end_inset

 respectively.
 The intersection of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 can be achieved by creating a third Turing Machine 
\begin_inset Formula $M$
\end_inset

.
 
\begin_inset Formula $M$
\end_inset

will be a two-tape Turing Machine.
 
\begin_inset Formula $M$
\end_inset

will proceed by copying the tape of 
\begin_inset Formula $M_{1}$
\end_inset

 to its first tape, and 
\begin_inset Formula $M_{2}$
\end_inset

 to its second tape.
 Next, 
\begin_inset Formula $M$
\end_inset

 will simulate the input of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 independently.
 In the case of Recursive Languages (Decidable Languages), 
\begin_inset Formula $M$
\end_inset

will 
\emph on
accept
\emph default
 when 
\series bold
both
\series default
 of its tapes enter an accepting state, and 
\emph on
reject
\emph default
 when 
\series bold
either
\series default
 of its tapes halt by not accepting.
 In the Recursively Enumerable case, 
\begin_inset Formula $M$
\end_inset

 has to enter an accepting state on 
\series bold
both
\series default
 of its tapes to accept.
 However, it may end up running forever and never provide an answer.
 
\end_layout

\begin_layout Subsubsection
Difference and Complement
\end_layout

\begin_layout Standard
Again the idea behind Difference and Complement is quite similiar to the
 intersection.
 The intersection of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 can be achieved by creating a third Turing Machine 
\begin_inset Formula $M$
\end_inset

.
 
\begin_inset Formula $M$
\end_inset

 will be a two-tape Turing Machine.
 
\begin_inset Formula $M$
\end_inset

 will proceed by copying the tape of 
\begin_inset Formula $M_{1}$
\end_inset

 to its first tape, and 
\begin_inset Formula $M_{2}$
\end_inset

 to its second tape.
 Next, 
\begin_inset Formula $M$
\end_inset

 will simulate the input of 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 independently.
 
\begin_inset Formula $M$
\end_inset

 will 
\emph on
accept
\emph default
 when 
\series bold

\begin_inset Formula $M_{1}$
\end_inset

 
\series default
accepts and 
\begin_inset Formula $M_{2}$
\end_inset

 rejects, otherwise reject.
 Corollary, for the complement run the difference algorithm over the Kleene
 star of the input alphabet.
 This approach won't work for Recursively Enumerable Languages because 
\begin_inset Formula $M_{2}$
\end_inset

 may never halt.
\end_layout

\begin_layout Subsubsection
Concatenation
\end_layout

\begin_layout Standard
Concatenation will require the use of a two-tape nondeterministic Turing
 Machine 
\begin_inset Formula $M$
\end_inset

.
 Assume that the given machines 
\begin_inset Formula $M_{1}$
\end_inset

 and 
\begin_inset Formula $M_{2}$
\end_inset

 are semi-inifinite single-tape Turing Machines.
 
\begin_inset Formula $M$
\end_inset

 will proceed by nondetminitically guessing the where a given input string
 
\begin_inset Formula $w$
\end_inset

 should be split.
 Call the prefix substring of 
\begin_inset Formula $w$
\end_inset

 the string 
\begin_inset Formula $x$
\end_inset

, and call the corresponding suffix 
\begin_inset Formula $y$
\end_inset

.
 Now copy 
\begin_inset Formula $x$
\end_inset

 onto 
\begin_inset Formula $M's$
\end_inset

 first tape and 
\begin_inset Formula $y$
\end_inset

onto its second tape.
 Now simulate 
\begin_inset Formula $M_{1}'s$
\end_inset

 transition function on the first tape and 
\begin_inset Formula $M_{2}'s$
\end_inset

 transtion function on the second tape.
 If both accept then 
\begin_inset Formula $M$
\end_inset

 should 
\emph on
accept
\emph default
, otherwise 
\emph on
reject
\emph default
.
 Because we nondeterministically guess all ways that 
\begin_inset Formula $w$
\end_inset

 can be split the machine will always accept if 
\begin_inset Formula $w$
\end_inset

 is in 
\begin_inset Formula $L(L(M_{1})L(M_{2})).$
\end_inset

 
\end_layout

\begin_layout Subsubsection
Kleene Star
\end_layout

\begin_layout Standard
For the Kleene star mirror the technique of used concatenation but instead
 of splitting the input string.
 Generate the Kleene star of the given Turing Machine and for each component
 of the guessed set run it against the Turing Machine and if it accepts
 then accept, otherwise reject.
\end_layout

\begin_layout Subsubsection
Reversal
\end_layout

\begin_layout Standard
Simply reverse the input and run it against the machine.
\end_layout

\begin_layout Section
Decidability
\begin_inset CommandInset label
LatexCommand label
name "sec:Undeciability"

\end_inset


\end_layout

\begin_layout Standard
Now that we have seen some algorithms in the preceeding section it is easy
 to see that one may create a great number of algorithms for Turing Machines.
 However, we will soon find out that for some problems no algorithm exists.
 We will link the concepts we learned in the Section
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Countability"

\end_inset

 to formulate a way of encoding Turing Machines in binary.
 This will allow us to apply the Diagonalization technique to Turing Machines.
 We can then formalize the notion that a problem posed to a Turing Machine
 is in fact the language of the Turing Machine.
 We can then see that for some languages no Turing Machine can exist.
\end_layout

\begin_layout Subsection
Encoding Turing Machines in Binary
\end_layout

\begin_layout Standard
It is quite simple to come up with a scheme for encoding Turing Machines
 into binary strings.
 We will assume the Turing Machines we will be encoding have a input alphate
 consisting of 
\begin_inset Formula $\{0,1\}.$
\end_inset

 However, this methodology is certainly exapandable to arbitrary alphabets.
 We should first assign integer values to the three classes of elements
 of the Turing Machine: states, symbols, and directions.
 Now we apply a trick for distinguishing codes of the binary string.
 For each integer representation of the componenet.
 Convert the integer to binary and insert a zero for each binary digit.
 Now there can never be consecutive ones in the binary representation.
 To distinguish between parts of the encoding add consecutive ones.
 Now we can concatenate the elements of the Turing machine together and
 prepend a 1 so that the encoding represents a unique integer value, and
 thus the language of all possible Turing Machines becomes enumerable.
 Some encodings may give invalid Turing Machines and therefore we regard
 theses as Turing Machines that accpet only the empty language.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="10">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String j
\begin_inset Formula $\rightarrow$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TM i
\begin_inset Formula $\rightarrow$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{1,1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{2,2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{3,3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{4,4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{5,5}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{6,6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="center" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ddots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:TuringMachineAcceptanceTable"

\end_inset

This table expreses which strings 
\begin_inset Formula $j$
\end_inset

 are accepted by which Turing Machines 
\begin_inset Formula $i$
\end_inset

.
 If 
\begin_inset Formula $x$
\end_inset

is 0 then the string is not accpeted, otherwise if 1 then it is accepted.
 The main diagonal 
\begin_inset Formula $D$
\end_inset

 is enumerated as 
\begin_inset Formula $a_{1,1},a_{2,2},a_{3,3},\ldots,a_{n,n}$
\end_inset

.
 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Diagonalization on the Enumerated Turing Machines
\begin_inset CommandInset label
LatexCommand label
name "subsec:DiagonalizationOnTuringMachines"

\end_inset


\end_layout

\begin_layout Standard
In order to diagonalize the table given by Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:TuringMachineAcceptanceTable"

\end_inset

.
 We form a sequence 
\begin_inset Formula $D$
\end_inset

 by complementing the values along the main diagonal.
 Formally 
\begin_inset Formula $D=$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $a_{i,j},\ldots,a_{n,n}$
\end_inset

 where 
\begin_inset Formula $i=j$
\end_inset

, and the value of 
\begin_inset Formula $a_{i,j}$
\end_inset

 is the complement of its value in the table shown in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:TuringMachineAcceptanceTable"

\end_inset

.
 Now we come to the question: Could 
\begin_inset Formula $D$
\end_inset

 be a row representing the language accepted by a Turing Machine of the
 table? Suppose this imaginary row represented by the main diagonal 
\begin_inset Formula $D$
\end_inset

 where row 
\begin_inset Formula $k$
\end_inset

, but it can't be row 
\begin_inset Formula $k$
\end_inset

 because it disagrees at the 
\begin_inset Formula $k^{th}$
\end_inset

 entry.
 Therefore this cannot be the language of any Turing Machine, and further
 we can descibe this language as the set that contains the 
\begin_inset Formula $k^{th}$
\end_inset

 string if and only if the 
\begin_inset Formula $k^{th}$
\end_inset

 Turing Machine does not accept the 
\begin_inset Formula $k^{th}$
\end_inset

 string.
 We can name this language 
\begin_inset Formula $L_{D}$
\end_inset

 and since we know that we can not create a Turing Machine for this langauge,
 then we know that it is not recursively enumeable (Turing-recogizable),
 and thus no algorithm can be given to decide 
\begin_inset Formula $L_{D}.$
\end_inset


\end_layout

\begin_layout Subsection
Decidable Problems
\end_layout

\begin_layout Standard
A problem is decidable if there is an algorithm to asnwer it.
 Recall, an algorithm formally speaking is a Turing Machine that halts on
 all inputs, accepted or not.
 Put another way a deciable problem is a recursive language.
 We may visualize the relationship among the language classes and the language
 
\begin_inset Formula $L_{D}$
\end_inset

 which we identified in subsection
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:DiagonalizationOnTuringMachines"

\end_inset

 in the Figure
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/DecidablityLanguageClass.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:DeciableLanguagesDiagram"

\end_inset

 Here we see the hierarchy of the language classes and how they relate to
 
\begin_inset Formula $L_{D}$
\end_inset

.
 The Undeciable Languages also called the Recursively Enumerable Languages
 have a Turing Machive and are regarded to be Turing-recognizable.
 That is, they have a Turing Machine that will accept strings, but there
 is no guarantee that the machine will halt.
 Within this class is the Decidable Languages also called the Recursive
 Languages which have Turing Machines which are guranteed to distinguish
 string as either accepted or rejected and they also are guranteed to halt.
 At the otter most ring we have the language for which no Turing Machine
 exists and therefore they are unrecognizable.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Universal Turing Machine
\end_layout

\begin_layout Standard
A Universal Turing Machine (UTM) is a Turing Machine which accepts as input
 a Turing Machine 
\begin_inset Formula $M$
\end_inset

 and some string 
\begin_inset Formula $w$
\end_inset

.
 The UTM accepts 
\begin_inset Formula $M$
\end_inset

 if and only if 
\begin_inset Formula $M$
\end_inset

accepts 
\begin_inset Formula $w.$
\end_inset

 A UTM will have three tapes.
 Tape 1 holds the input 
\begin_inset Formula $M$
\end_inset

encoded as binary and 
\begin_inset Formula $w.$
\end_inset

 Tape 2 holds the tape of 
\begin_inset Formula $M$
\end_inset

, and Tape 3 holds the state of 
\begin_inset Formula $M.$
\end_inset

 The UTM proceeds by first checking the encoding of 
\begin_inset Formula $M.$
\end_inset

 If 
\begin_inset Formula $M$
\end_inset

 is invalid, then its language is the empty language, and the UTM halts
 immediately and rejects.
 The UTM will then examine the size of 
\begin_inset Formula $M's$
\end_inset

 symbols to determine the required word size.
 Next, the UTM will initialize Tape 2 to represent the tape of 
\begin_inset Formula $M$
\end_inset

with the input 
\begin_inset Formula $w$
\end_inset

, and initialize Tape 3 to hold the start state.
 Finally, the UTM can simulate 
\begin_inset Formula $M$
\end_inset

 by looking for a step in the transition function of 
\begin_inset Formula $M$
\end_inset

encoded on Tape 1 that matches the state encoded on Tape 3 with a tape symbol
 under the head of Tape 2.
 If a match is found change the symbol and move the head marker on Tape
 2 and change the State on Tape 3.
 If 
\begin_inset Formula $M$
\end_inset

accepts, then the UTM accepts.
\end_layout

\begin_layout Subsection
The UTM is Recursively Enumerable and Not Recursive (The Halting Problem)
\end_layout

\begin_layout Standard
Assume for the purposes of contradiction that the language of the UTM, that
 is 
\begin_inset Formula $L(UTM)$
\end_inset

, is recursive (decidable).
 Meaning that for every input it halts and returns an accepting or rejecting
 answer.
 We 
\emph on
somehow magically discover
\emph default
 an algorithm that can decide whether given a Turing Machine
\begin_inset Formula $M$
\end_inset

 and an input string 
\begin_inset Formula $w$
\end_inset

 from the acceptance table featured in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:TuringMachineAcceptanceTable"

\end_inset

– call this algorithm 
\emph on
wizzBang.
 
\emph default
Remember 
\emph on
wizzBang 
\emph default
takes two paramters as arguments.
 First, we must have a valid Turing Machine 
\begin_inset Formula $M$
\end_inset

, and second we must have a string 
\begin_inset Formula $w.$
\end_inset

 We’re given an input 
\begin_inset Formula $M$
\end_inset

.
 Let’s suppose 
\begin_inset Formula $M$
\end_inset

 is for the i-th string 
\begin_inset Formula $w$
\end_inset

 of our table.
 The first thing to do is check whether or not 
\begin_inset Formula $M$
\end_inset

 is a valid encoding for a Turing machine.
 If the encoding is NOT valid, then the i-th Turing Machine defines the
 empty language.
 That means 
\begin_inset Formula $w$
\end_inset

, the i-th string, is not in the language of the i-th Turing machine.
 Therefore, 
\begin_inset Formula $w$
\end_inset

 IS in 
\begin_inset Formula $L_{D}$
\end_inset

.
 Remeber we complemented the major diagonal so that answers here must be
 inverted.
 Now suppose 
\begin_inset Formula $M$
\end_inset

 is a valid encoding for a Turing machine.
 Then run 
\emph on
wizzBang
\emph default
 on the input 
\begin_inset Formula $M$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

.
 Here 
\begin_inset Formula $M$
\end_inset

 represents the i-th Turing Machine processing the input that is the i-th
 string.
 Eventually, this algorithm will halt and tell us whether or not the i-th
 machine accepts the i-th string.
 If the 
\emph on
wizzBang
\emph default
 accepts the i-th machine accepts the i-th string, then we say reject because
 that means 
\begin_inset Formula $w$
\end_inset

 is not in 
\begin_inset Formula $L_{D}$
\end_inset

.
 However, if 
\emph on
wizzBang
\emph default
 rejects, then we accept 
\begin_inset Formula $w$
\end_inset

, because 
\begin_inset Formula $w$
\end_inset

 IS in 
\begin_inset Formula $L_{D}$
\end_inset

.
 HERE IS THE MAIN POINT
\begin_inset Formula $\Rightarrow$
\end_inset

 We previously proved in subsection
\begin_inset CommandInset ref
LatexCommand vref
reference "subsec:DiagonalizationOnTuringMachines"

\end_inset

 that no Turing Machine can exist for 
\begin_inset Formula $L_{D}$
\end_inset

 and therefore we must conclude that 
\emph on
wizzBang cannot exist.
 
\emph default
This tells us that the UTM is Recursively Enumerable (Turing-recognizable),
 but not Recursive (Decidable).
 
\end_layout

\begin_layout Section
Some Undeciable Problems
\end_layout

\begin_layout Standard
In this section we cover Rice's Theorem which states that almost every question
 we ask about Recursively Enumerable Languages is undeciable.
 Next we look to Post's Correspondence Problem to bridge the gap between
 the world of Turing Machine to solving real world problems.
 In addition to the classical language classes we have defined we may define
 properties of languages.
 A property is a user defined set of languages.
 For example, the set of languages who are infinite languages have the Infiniten
ess Property.
 We can define a language 
\begin_inset Formula $L_{P}$
\end_inset

 as the set of TM's such that each TM has the property 
\begin_inset Formula $P$
\end_inset

.
 There are two trivial propertues 
\begin_inset Formula $P$
\end_inset

 for which 
\begin_inset Formula $L_{P}$
\end_inset

 is deciable.
 The always-false propety, which contains no Recursively Enumerable languages,
 and the always-true property, which contains every Recursively Enumerable
 language.
 Rice's Theorem states that for every other property 
\begin_inset Formula $P$
\end_inset

 besides the trivial ones 
\begin_inset Formula $L_{P}$
\end_inset

 is undecidable.
 In order to prove Rice's Theorem we will have to introduce the concept
 of reductions.
 A reduction is an algorithm (Recall, an algorithm is a TM that always halts),
 which transforms an input string 
\begin_inset Formula $w$
\end_inset

 in 
\begin_inset Formula $L$
\end_inset

 to a string 
\begin_inset Formula $x$
\end_inset

in 
\begin_inset Formula $L'$
\end_inset

 with the property that 
\begin_inset Formula $x$
\end_inset

is in 
\begin_inset Formula $L'$
\end_inset

 if and only if 
\begin_inset Formula $w$
\end_inset

 is in 
\begin_inset Formula $L.$
\end_inset

 The takeaway here is that given the reduction for 
\begin_inset Formula $L$
\end_inset

 we are able to say that 
\begin_inset Formula $L$
\end_inset

 is no harder than 
\begin_inset Formula $L'.$
\end_inset

 We can visualize reductions as shown in Figure
\begin_inset CommandInset ref
LatexCommand vref
reference "fig:Reductions"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Diagrams/Reduction.svg
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Reductions"

\end_inset

 The transducer serves as an adaptor for the input string of 
\begin_inset Formula $w$
\end_inset

.
 It transforms 
\begin_inset Formula $w$
\end_inset

 into a string 
\begin_inset Formula $x$
\end_inset

which 
\begin_inset Formula $L'$
\end_inset

 can consume and produce an accept or reject decision.
 Algorithm 
\begin_inset Formula $L'$
\end_inset

 allows us to draw conclusions about the properties of 
\begin_inset Formula $L.$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Rice's Theorem
\end_layout

\begin_layout Standard
We now need to prove the claim of Rice's Theorem: Every nontrivial property
 
\begin_inset Formula $P$
\end_inset

 of the Recursively Enumerable languages, 
\begin_inset Formula $L_{P}$
\end_inset

, is undecidable.
 
\end_layout

\begin_layout Subsection
Post's Correspondence Problem
\end_layout

\begin_layout Subsection
Some Real Problems
\end_layout

\begin_layout Section
Big-O Analysis (Bachmann-Landau Notation)
\begin_inset CommandInset label
LatexCommand label
name "sec:Big-O-Analysis"

\end_inset


\end_layout

\begin_layout Section
P and NP
\begin_inset CommandInset label
LatexCommand label
name "sec:P-and-NP"

\end_inset


\end_layout

\begin_layout Section
Satisfiability and Cook's Theorem
\begin_inset CommandInset label
LatexCommand label
name "sec:Satisfiability-and-Cook's"

\end_inset


\end_layout

\begin_layout Section
NP-Complete Problems
\begin_inset CommandInset label
LatexCommand label
name "sec:NP-Complete-Problems"

\end_inset


\end_layout

\begin_layout Section
Probability and Odds
\begin_inset CommandInset label
LatexCommand label
name "sec:Probability-and-Odds"

\end_inset


\end_layout

\begin_layout Section
Approximation Algorithms
\begin_inset CommandInset label
LatexCommand label
name "sec:Approximation-Algorithms"

\end_inset


\end_layout

\begin_layout Section
Randomization Algorithms
\begin_inset CommandInset label
LatexCommand label
name "sec:Randomization-Algorithms"

\end_inset


\end_layout

\begin_layout Section
Dynamic Programming
\begin_inset CommandInset label
LatexCommand label
name "sec:Dynamic-Programming"

\end_inset


\end_layout

\begin_layout Section
Fast Fourier Transform
\begin_inset CommandInset label
LatexCommand label
name "sec:Fast-Fourier-Transform"

\end_inset


\end_layout

\begin_layout Section
Representing Graphs
\begin_inset CommandInset label
LatexCommand label
name "sec:representingGraphs"

\end_inset


\end_layout

\begin_layout Section
Maximum Flow
\begin_inset CommandInset label
LatexCommand label
name "sec:Maximum-Flow"

\end_inset


\end_layout

\begin_layout Section
Bipartite Matching
\begin_inset CommandInset label
LatexCommand label
name "sec:Bipartite-Matching"

\end_inset


\end_layout

\begin_layout Section
Linear Programming
\begin_inset CommandInset label
LatexCommand label
name "sec:Linear-Programming"

\end_inset


\end_layout

\begin_layout Section
Duality
\begin_inset CommandInset label
LatexCommand label
name "sec:Duality"

\end_inset


\end_layout

\begin_layout Section
Appendix: Mathematics
\begin_inset CommandInset label
LatexCommand label
name "sec:Appendix:-Mathematics"

\end_inset


\end_layout

\begin_layout Section
Appendix: Reference Material
\begin_inset CommandInset label
LatexCommand label
name "sec:Appendix:-Reference-Material"

\end_inset


\end_layout

\begin_layout Standard
The following sections provide some useful resources that will help you
 along the way.
 
\end_layout

\begin_layout Subsection
Software
\end_layout

\begin_layout Itemize
Draw.io is a online tool for creating all sorts of diagrams.
 It will be useful when creating automata.
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.draw.io
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
LyX is a \SpecialChar LaTeX
 word processing application that will be useful when drafting
 homework.
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.lyx.org
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Python is a useful programming language for experimenting with algorithms.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.python.org
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Mendeley is a good tool to organize your electronic library of books and
 journal articles.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.mendeley.com/
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Mathematica or MatLab to help your with linear programming 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://software.oit.gatech.edu
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Books
\end_layout

\begin_layout Itemize
How to Prove It: A Structured Approach by Daniel J.
 Velleman 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0521675995
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Mathematical Reasoning: Writing and Proof by Ted Sundstrom 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/1500143413
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Introduction to the Theory of Computation by Michael Sipser 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/113318779X
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Discrete Mathematics and Its Applications by Kenneth Rosen 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0073383090
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Linear and Nonlinear Programming by David Luenberger and Ye Yingyu 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/3319188410
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Algorithm Design by Jon Kleinberg and Eva Tardos 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0321295358
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Introduction to Automata Theory, Languages and Computation by John Hopcroft,
 Rajeev Motwani and Jeffery Ullman 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0321455363
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Book of Proof by Richard Hammack 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0989472108
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Algorithms by Sanjoy Dasgupta, Christos Papadimitriou, and Vijay Vazirani
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0073523402
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Introduction to Algorithms by Thomas Cormen, Charles Leiserson, Ronald Rivest,
 and Clifford Stein 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://amzn.com/0262033844
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Videos
\end_layout

\begin_layout Itemize
Professor Harry Porter's YouTube playlist on the theory of computation.
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.youtube.com/playlist?list=PLbtzT1TYeoMjNOGEiaRmm_vMIwUAidnQz
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Professor Tim Roughgardener's playlist on Logic 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.youtube.com/playlist?list=PLLH73N9cB21Xsgy39DP3xDqBN3lTaR8R5
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
Professor Tim Roughgardener's playlist on Data Structures and Algorithms
 I 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.youtube.com/playlist?list=PLLH73N9cB21W1TZ6zz1dLkyIm50HylGyg
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
Professor Tim Roughgardener's playlist on Data Structures and Algorithms
 II 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://www.youtube.com/playlist?list=PLLH73N9cB21VPj3H2xwTTye5TC8-UniA2
\end_layout

\end_inset


\end_layout

\end_body
\end_document
